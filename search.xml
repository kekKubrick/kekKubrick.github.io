<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020电影札记</title>
      <link href="/2020/04/09/dian-ying-zha-ji/"/>
      <url>/2020/04/09/dian-ying-zha-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我喜爱的电影导演"><a href="#我喜爱的电影导演" class="headerlink" title="我喜爱的电影导演"></a>我喜爱的电影导演</h2><ul><li>Stanley Kubrick</li><li>徐克</li><li>王家卫</li><li>Christopher Nolan</li><li>忻钰坤</li></ul><h2 id="我喜爱的电影"><a href="#我喜爱的电影" class="headerlink" title="我喜爱的电影"></a>我喜爱的电影</h2><ul><li>美丽人生</li><li>巴里·林登</li><li>东邪西毒 </li><li>末代皇帝</li><li>2001太空漫游 </li><li>万物理论</li><li>敦刻尔克</li><li>奇爱博士</li><li>思悼</li><li>杀人回忆</li><li>坠入 </li><li>全金属外壳</li><li>大话西游之月光宝盒</li><li>大话西游之大圣娶亲</li><li>梁祝</li></ul><h2 id="我喜爱的导演混剪-影片分析-采访"><a href="#我喜爱的导演混剪-影片分析-采访" class="headerlink" title="我喜爱的导演混剪/影片分析/采访"></a>我喜爱的导演混剪/影片分析/采访</h2><p><a href="https://www.bilibili.com/video/BV147411r7DA" target="_blank" rel="noopener">库布里克&amp;塔科夫斯基镜头对比</a></p><p><a href="https://www.xinpianchang.com/a52439?from=search_post" target="_blank" rel="noopener">娄烨导演电影混剪</a></p><p><a href="https://www.bilibili.com/video/BV1ps411P7h2" target="_blank" rel="noopener">徐克专访</a></p><p><a href="https://www.bilibili.com/video/BV1ub411a7ai" target="_blank" rel="noopener">盖里奇电影混剪</a></p><p><a href="https://www.bilibili.com/video/BV1uJ41157wV" target="_blank" rel="noopener">《敦刻尔克》结构性剪辑</a></p>]]></content>
      
      
      <categories>
          
          <category> 电影札记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影札记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 重复的数字</title>
      <link href="/2020/04/05/chong-fu-de-shu-zi/"/>
      <url>/2020/04/05/chong-fu-de-shu-zi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="03-重复的数字"><a href="#03-重复的数字" class="headerlink" title="03 重复的数字"></a>03 重复的数字</h2><blockquote><p>难度：简单</p></blockquote><blockquote><p>找出数组中重复的数字。</p></blockquote><blockquote><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p></blockquote><blockquote><p>示例 1：</p></blockquote><blockquote><p>输入：[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote><blockquote><p>限制：</p></blockquote><blockquote><p>2 &lt;= n &lt;= 100000</p></blockquote><p>思路：排序、比较、防止数组越界</p><p>代码：</p><pre class=" language-c"><code class="language-c">class Solution <span class="token punctuation">{</span>         public<span class="token punctuation">:</span><span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//排序</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//防越界</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//比较</span>               <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>              <span class="token punctuation">}</span>       <span class="token punctuation">}</span>     <span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" target="_blank" rel="noopener">来源：LeetCode</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 drag API</title>
      <link href="/2019/08/05/html5-drag-api/"/>
      <url>/2019/08/05/html5-drag-api/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML5-drag-API"><a href="#HTML5-drag-API" class="headerlink" title="HTML5 drag API"></a>HTML5 drag API</h2><h3 id="前言：mousedown事件"><a href="#前言：mousedown事件" class="headerlink" title="前言：mousedown事件"></a>前言：mousedown事件</h3><p>以前实现拖拽，主要有以下几步：</p><ol><li><p>目标元素绑定mousedown事件，记录下此时鼠标位置和拖拽元素的位置差，分别是 diffX ,diffY</p></li><li><p>在mousedown中绑定 document的mousemove 以及mouseup</p></li><li><p>在mousemove中计算拖拽元素的位置： x = event.clientX - diffX ,y = event.clientY - diffY</p></li><li><p>mouseup时中销毁绑定的 document mousemove 和mouseup事件，销毁拖拽元素</p></li></ol><p><strong>当一个元素拖拽的时候，鼠标顺序依次：mousedown,mousemove,mouseup,click</strong>, 如果一个元素既可以点击，又需要拖拽，可能导致，我们拖着拖着发生了点击事件，页面跳转了。这时候，我们通常会采用延时操作，避免误操作。总之，处理起来是麻烦的。</p><hr><h3 id="drag系列事件"><a href="#drag系列事件" class="headerlink" title="drag系列事件"></a>drag系列事件</h3><p>有了<strong>html5 drag</strong>，浏览器自动帮我们处理好了。需要注意的是,<strong>drag系列事件不能跟mousemove共存</strong>，只能取其一。</p><ul><li><p>拖拽和释放定义 </p><ul><li><p>拖拽：Drag;</p></li><li><p>释放：Drop;    </p></li></ul></li><li><p>源对象和目标对象</p><ul><li><p>Drop here(目标对象)</p></li><li><p>Drop me to my target(源对象)       </p></li></ul></li><li><p>相关API:</p><ul><li><p>ondragstart:事件主体是源对象，源对象开始被拖动时触发</p></li><li><p>ondrag:事件主体是源对象，源对象被拖动的过程时触发</p></li><li><p>ondragend:事件主体是源对象，在整个拖放操作结束时触发。</p></li><li><p>ondragenter:事件主体是目标对象，源对象进入目标元素时触发</p></li><li><p>ondragover:事件主体是目标对象，在源对象在目标对象内移动时触发。</p></li><li><p>ondragleave:事件主体是目标对象，源对象拖动着离开了目标对象时触发</p></li><li><p>ondrop:事件主体是目标对象，在目标元素完全接受被拖放元素时触发。</p></li></ul></li></ul><p>其中事件主体是拖放元素的是<strong>dragstart（开始拖动） 、darg（正在拖放） 、dragend（拖放结束）</strong>，其他4个事件主体都是目标元素，进入、移动、离开、完全进入四个状态。</p><hr><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>要让一个元素支持拖拽，首先我们需要在标签上标示出来：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div draggable<span class="token operator">=</span><span class="token string">"true"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><p>对于Safari，还必须要在CSS中对能拖拽的元素如下设置：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">*</span><span class="token punctuation">[</span>draggable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token operator">-</span>khtml<span class="token operator">-</span>user<span class="token operator">-</span>drag<span class="token punctuation">:</span> element<span class="token punctuation">;</span><span class="token punctuation">}</span>     </code></pre><p>注意：<strong>为了减少事件，你可以在事件 ondragenter 的时候绑定方法 ，而 ondragleave 的时候，删除方法。</strong> 最好不要绑定在 dragover 上，它就像 mouseover ，在拖动的过程中不断触发，对于浏览器的负担就很大了，浏览器还有可能崩溃。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'dragstart'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'dragend'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>如此，就可以让元素拖动了。  </p><p>有了HTML5 drag API,判断拖拽元素跟其他dom元素相交变得容易起来了，只需要：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.drop-area'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'dragover'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dragover'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//需要注意的是，必须写上这个部分，如果不阻止默认事件，drop事件将不会触发。关于这点，可以去w3c查看。</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.drop-area'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'drop'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'drop'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="dataTransfer对象实现数据交换"><a href="#dataTransfer对象实现数据交换" class="headerlink" title="dataTransfer对象实现数据交换"></a>dataTransfer对象实现数据交换</h3><ul><li><p>拖动的源对象和目标对象之间的数据传递：</p><ul><li><p>源对象数据保存：e.data.Transfer.setData(k,v)//k-v必须都是string类型</p></li><li><p>目标对象获取数据：e.data.Transfer.getData(k,v)</p></li></ul></li></ul><p>只有简单的拖放而没有数据变化是没有什么用的。为了在拖放操作时实现数据交换HTML5定义了<strong>dataTransfer对象</strong>来传递拖拽的数据。</p><p>因为它是事件对象的属性，所以只能在拖放事件的事件处理程序中访问dataTransfer对象。在事件处理程序中，可以使用这个对象的属性和方法来完善拖放功能。<br>getData()和setData()</p><p><strong>dataTransfer对象有 getData()和setData()两个主要方法</strong>，操作dataTransfer中携带的数据。不难想象，<strong>getData()可以取得由setData()保存的值。setData()方法的第一个参数，也是getDAta()方法唯一的一个参数，表示保存的数据类型</strong>。</p><p>IE只定义了“text”和“URL”两种有效的数据类型，而HTML5则对此加以扩展，允许指定各种MIME类型。考虑到向后兼容，HTML5也支持“text”和“URL”，但这两种类型会被映射为“text/plain”和“text/uri-list”。如下所示：</p><ul><li>text/html：文本文字格式</li><li>text/plain：HTML代码格式</li><li>text/xml：XML字符格式</li><li>text/url-list：URL格式列表</li></ul><p>实际上，dataTransfer对象可以为每种MIME类型都保存一个值。换句话说，同时在这个对象中保存了一段文本和一个URL不会有任何问题。不过，保存在dataTransfer对象中的数据只能在drop事件处理程序中读取。如果在ondrop处理程序中没有读到数据，那就是dataTransfer对象已经被销毁，数据也丢失了。</p><p>在拖动文本框中的文本时，浏览器会调用setData()方法，将拖动的文本以“text”格式保存在dataTransfer对象中。类似地，在拖放链接或图像时，会调用setData()方法并保存URL。然后，在这些元素被拖放到放置目标时，就可以通过getData()读到这些数据。当然，作为开发人员，你也可以在dragstart事件处理程序中调用setData()，手工保存自己要传输的数据，以便将来使用。</p><p>将数据保存为文本和保存为URL是有区别的。如果将数据保存为文本格式，那么数据不会得到任何特殊处理。而如果将数据保存为URL，浏览器会将其当成网页中的链接。换句话说，如果你把它放置到另一个浏览器窗口中，浏览器就会打开该URL。</p><p>Firefox在其第5个版本之前不能正确地将“URL”和“text”映射为“text/uri-list”和“text/plain”。但是却能把“Text”映射为“text/plain”。为了更好地在跨浏览器的情况下从dataTransfer对象取得数据，最好在取得URL数据时检测两个值，而在取得文本数据时使用“text”。</p><p>var dataTransfer =event.dataTransfer;//读取URLvar url = dataTransfer.getData(“url”)|| dataTransfer.getData(“text/uri-list”);//读取文本var text = dataTransfer.getData(“Text”);</p><p>注意：一定要把短数据类型放在前面，因为IE 10及之前的版本仍然不支持扩展的MIME类型名，而它们在遇到无法识别的数据类型时，会抛出错误。</p><hr><h3 id="使用-setDragImage-方法设置拖放图标"><a href="#使用-setDragImage-方法设置拖放图标" class="headerlink" title="使用 setDragImage 方法设置拖放图标"></a>使用 setDragImage 方法设置拖放图标</h3><p>在HTML5中，一个元素在被拖放时，还可以自定义拖放元素的鼠标图标。调用格式如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setDragImage</span><span class="token punctuation">(</span>Element img<span class="token punctuation">,</span>long x<span class="token punctuation">,</span>long y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//img表示拖放时的 &lt;> 元素的图标，x 表示图标距离鼠标指针的x轴方向的偏移值，y表示图标距离鼠标指针y轴方向的偏移值。</span></code></pre><hr><h3 id="使用-effectAllowed-和-dropEffect-属性设置拖放效果"><a href="#使用-effectAllowed-和-dropEffect-属性设置拖放效果" class="headerlink" title="使用 effectAllowed 和 dropEffect 属性设置拖放效果"></a>使用 effectAllowed 和 dropEffect 属性设置拖放效果</h3><p>dataTransfer对象的两个属性：dropEffect和effectAllowed，能通过它来确定被拖动的元素以及作为放置目标的元素能够接受什么操作。结合effectAllowed 和 dropEffect 这两个属性，可以自定义拖放过程中的效果。两个属性虽然都是为了实现同一功能，但绑定的元素不同：<strong>effectAllowed属性作用于被拖放元素；而 dropEffect 属性作用于目标元素。</strong></p><p>其中，通过dropEffect属性可以知道被拖动的元素能够执行哪种放置行为。这个属性有下列4个可能的值。  </p><ul><li>none：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。</li><li>move：应该把拖动的元素移动到放置目标</li><li>copy：应该把拖动的元素复制到放置目标</li><li>link：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有URL）。</li></ul><p>在把元素拖动到放置目标上时，以上每一个值都会导致光标显示为不同的符号。然而，要怎样实现光标所指示的动作完全取决于你。换句话说，如果你不介入，没有什么会自动地移动、复制，也不会打开链接。总之，浏览器只能帮你改变光标的样式，而其它的都要靠你自己来实现。要使用dropEfect属性，必须在ondraggenter事件处理程序中针对放置目标来设置它。</p><p>dropEffect属性只有搭配effectAllowed属性才有用。effectAllowed属性表示允许拖放元素的哪种dropEffect，effectAllowed属性可能的值如下。</p><ul><li>uninitialized：没有该被拖动元素放置行为。</li><li>none：被拖动的元素不能有任何行为。</li><li>copy：只允许值为“copy”的dropEffect。</li><li>link：只允许值为“link”的dropEffect。</li><li>move：只允许值为“move”的dropEffect。</li><li>copyLink：允许值为“copy”和“link”的dropEffect。</li><li>copyMove：允许值为“copy”和”link”的dropEffect。</li><li>linkMove：允许职位“link”和”move”的dropEffect。</li><li>all：允许任意dropEffect。</li></ul><p>必须在ondraggstart事件处理程序中设置effectAllowed属性。</p><p>假设你想允许用户把文本框中的文本拖放到一个div元素中。首先，必须将dropEffect和effectAllowed设置为”move”。但是，由于div元素的放置事件的默认行为是什么也不做，所以文本不可能自动移动。重写这个默认行为，就能从文本框中移走文本。然后你就可以自己编写代码将文本插入到div中，这样整个拖放操作就完成了。如果将dropEffect和effectAllowed的值设置为”copy”，那就不会自动移走文本框中的文本。<br>其它属性</p><ul><li>addElement：事件主体是被拖放元素，为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖动源而影响回调的对象），不会影响拖动操作时页面元素的外观。在写作文本时，只有Firefox 3.5+实现了这个方法。</li><li>clearData：事件主体是目标元素，清除以特定格式保存的数据。实现这个方法的浏览器有IE、Firefox 3.5、Chrome和Safari 4+。</li><li>types：当前保存的数据类型。这是一个类似数组的集合，以“text”这样的字符串形式保存着数据类型。实现这个属性的浏览器有IE10+、Firefox 3.5+和Chrome。</li></ul><p>支持draggable属性的浏览器有IE10+、Firefox 4+、Safari 5+和Chrome。Opera 11.5以及之前的版本都不支持HTML5的拖放功能。另外，为了让Firefox 支持可拖动属性，还必须添加一个ondragstart事件处理程序，并在dataTransfer对象中保存了一些信息。  </p><hr><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p><a href="https://www.cnblogs.com/wuya16/p/DragApi.html" target="_blank" rel="noopener">html5 drag api详解</a>  </p><p><a href="https://www.cnblogs.com/yangguoe/p/9681692.html" target="_blank" rel="noopener">html5的拖拽dragAPI（包含三个案例)</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http常见的状态码</title>
      <link href="/2019/08/05/http-chang-jian-de-zhuang-tai-ma/"/>
      <url>/2019/08/05/http-chang-jian-de-zhuang-tai-ma/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="http常见的状态码"><a href="#http常见的状态码" class="headerlink" title="http常见的状态码"></a>http常见的状态码</h2><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><p>200 OK，表示从客户端发来的请求在服务器端<strong>被正确处理</strong></p></li><li><p>204 No content，表示请求成功，但响应报文<strong>不含实体的主体部分</strong></p></li><li><p>206 Partial Content，进行<strong>范围请求</strong></p></li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><p>301 moved permanently，<strong>永久性</strong>重定向，表示资源已被分配了新的 URL</p></li><li><p>302 found，<strong>临时性</strong>重定向，表示资源临时被分配了新的 URL</p></li><li><p>303 see other，表示资源存在着另一个 URL，<strong>应使用 GET 方法定向获取资源</strong></p></li><li><p>304 not modified，表示服务器允许访问资源，但因发生<strong>请求未满足条件</strong>的情况</p></li><li><p>307 temporary redirect，<strong>临时重定向，和302含义相同</strong></p></li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><p>400 bad request，请求报文存在<strong>语法错误</strong></p></li><li><p>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的<strong>认证信息</strong></p></li><li><p>403 forbidden，表示对请求资源的访问被<strong>服务器拒绝</strong></p></li><li><p>404 not found，表示在服务器上<strong>没有找到</strong>请求的资源</p></li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li><p>500 internal sever error，表示服务器端在<strong>执行</strong>请求时发生了<strong>错误</strong></p></li><li><p>503 service unavailable，表明服务器暂时处于<strong>超负载或正在停机维护</strong>，<strong>无法处理请求</strong></p></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>400状态码：请求无效   </p><ul><li>产生原因：   <ul><li>前端提交数据的字段名称和字段类型与后台的实体没有保持一致   </li><li>前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。   </li></ul></li><li>解决方法：   <ul><li>对照字段的名称，保持一致性   </li><li>将obj对象通过JSON.stringify实现序列化   </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Fetch API</title>
      <link href="/2019/08/05/shi-yong-fetch/"/>
      <url>/2019/08/05/shi-yong-fetch/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="使用Fetch"><a href="#使用Fetch" class="headerlink" title="使用Fetch"></a>使用Fetch</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>无论用JavaScript发送或获取信息，我们都会用到Ajax。Ajax不需要刷新页面就能发送和获取信息，能使网页实现异步更新。</p><p>几年前，初始化Ajax一般使用jQuery的ajax方法：</p><pre class=" language-javascript"><code class="language-javascript">    $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'some-url'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      success<span class="token punctuation">:</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* do something with the data */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      error<span class="token punctuation">:</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* do something when an error happens */</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>也可以不用jQuery，但不得不使用XMLHttpRequest，然而这是相当复杂</p><p>幸亏，浏览器现在支持<strong>Fetch API，可以无须其他库就能实现Ajax</strong>。</p><hr><h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>Fetch API 提供了一个 JavaScript 接口，<strong>用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。</strong>它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来<strong>跨网络异步获取资源</strong>。</p><p>这种功能以前是使用 XMLHttpRequest 实现的。Fetch 提供了一个更理想的替代方案，可以很容易地被其他技术使用，例如  Service Workers。Fetch 还提供了专门的逻辑空间来定义其他与 HTTP 相关的概念，例如 CORS 和 HTTP 的扩展。</p><p>请注意，fetch 规范与 jQuery.ajax() 主要有三种方式的不同：</p><ul><li>当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise <strong>不会</strong>被标记为 <strong>reject</strong>， <strong>即使响应的 HTTP 状态码是 404（在服务器上没有找到请求的资源） 或 500（服务器端在执行请求时发生了错误）</strong>。相反，它会将 Promise 状态<strong>标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ）</strong>，<strong>仅当网络故障时或请求被阻止时，才会标记为 reject</strong>。</li><li>fetch() <strong>不会接受跨域 cookies</strong>；你也不能使用 fetch() 建立起跨域会话。其他网站的 Set-Cookie 头部字段将会被无视。</li><li>fetch <strong>不会发送 cookies</strong>。除非你使用了credentials 的初始化选项。（自 2017 年 8 月 25 日以后，默认的 credentials 政策变更为 same-origin。Firefox 也在 61.0b13 版本中进行了修改）</li></ul><p>一个基本的 fetch 请求设置起来很简单。看看下面的代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://example.com/movies.json'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>myJson<span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myJson<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里我们通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 fetch() 到的资源路径，然后返回一个包含响应结果的promise（一个 Response 对象）。</p><p>当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用 json() 方法（在 Body mixin 中定义，被 Request 和 Response 对象实现）。</p><p>注意：Body mixin 还有其他相似的方法，用于获取其他类型的内容。参考 Body。</p><p>最好使用符合内容安全策略 (CSP)的链接而不是使用直接指向资源地址的方式来进行Fetch的请求。</p><hr><h4 id="支持的请求参数"><a href="#支持的请求参数" class="headerlink" title="支持的请求参数"></a>支持的请求参数</h4><p>fetch() 接受第二个可选参数，一个可以控制不同配置的 init 对象：</p><p>参考 fetch()，查看所有可选的配置和更多描述。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token comment" spellcheck="true">// Example POST method implementation:</span>    <span class="token function">postData</span><span class="token punctuation">(</span><span class="token string">'http://example.com/answer'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>answer<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// JSON from `response.json()` call</span>      <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">function</span> <span class="token function">postData</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Default options are marked with *</span>      <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span>        body<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// must match 'Content-Type' header</span>        cache<span class="token punctuation">:</span> <span class="token string">'no-cache'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// *default, no-cache, reload, force-cache, only-if-cached</span>        credentials<span class="token punctuation">:</span> <span class="token string">'same-origin'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// include, same-origin, *omit</span>        headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>          <span class="token string">'user-agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/4.0 MDN Example'</span><span class="token punctuation">,</span>          <span class="token string">'content-type'</span><span class="token punctuation">:</span> <span class="token string">'application/json'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        method<span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// *GET, POST, PUT, DELETE, etc.</span>        mode<span class="token punctuation">:</span> <span class="token string">'cors'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// no-cors, cors, *same-origin</span>        redirect<span class="token punctuation">:</span> <span class="token string">'follow'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// manual, *follow, error</span>        referrer<span class="token punctuation">:</span> <span class="token string">'no-referrer'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// *client, no-referrer</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// parses response to JSON</span>    <span class="token punctuation">}</span></code></pre><hr><h4 id="发送带凭据的请求"><a href="#发送带凭据的请求" class="headerlink" title="发送带凭据的请求"></a>发送带凭据的请求</h4><p>为了让浏览器发送包含凭据的请求（即使是跨域源），要将credentials: ‘include’添加到传递给 fetch()方法的init对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://example.com'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>   credentials<span class="token punctuation">:</span> <span class="token string">'include'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加 credentials:<br>‘same-origin’。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// The calling script is on the origin 'https://example.com'</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://example.com'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>   credentials<span class="token punctuation">:</span> <span class="token string">'same-origin'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>要改为确保浏览器不在请求中包含凭据，请使用 credentials: ‘omit’。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://example.com'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>   credentials<span class="token punctuation">:</span> <span class="token string">'omit'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="使用-Fetch-POST-上传-JSON-数据"><a href="#使用-Fetch-POST-上传-JSON-数据" class="headerlink" title="使用 Fetch( ) POST 上传 JSON 数据"></a>使用 Fetch( ) POST 上传 JSON 数据</h4><ul><li><strong>fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？</strong>   </li><li>原因:  </li><li><strong>因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</strong></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'https://example.com/profile'</span><span class="token punctuation">;</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>username<span class="token punctuation">:</span> <span class="token string">'example'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span>     method<span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// or 'PUT'</span>     body<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// data can be `string` or {object}!</span>     headers<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Headers</span><span class="token punctuation">(</span><span class="token punctuation">{</span>     <span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'application/json'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Error:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Success:'</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="实践Fetch发送数据"><a href="#实践Fetch发送数据" class="headerlink" title="实践Fetch发送数据"></a>实践Fetch发送数据</h5><p>使用Fetch发送很简单，只需要配置三个参数。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'some-url'</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p>第一个参数是设置请求方法（如post、put或del），Fetch会自动设置方法为get。</p></li><li><p>第二个参数是设置头部。因为一般使用JSON数据格式，所以设置ContentType为application/json。</p></li><li><p>第三个参数是设置包含JSON内容的主体。因为JSON内容是必须的，所以当设置主体时会调用JSON.stringify。</p></li></ul><p>实践中，post请求会像下面这样：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">let</span> content <span class="token operator">=</span> <span class="token punctuation">{</span>some<span class="token punctuation">:</span> <span class="token string">'content'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// The actual fetch request</span>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'some-url'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      method<span class="token punctuation">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>      headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'application/json'</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      body<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// .then()...</span></code></pre><hr><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>可以通过 HTML input type=”file”  元素，FormData() 和 fetch() 上传文件。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> fileField <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"input[type='file']"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token string">'abc123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'avatar'</span><span class="token punctuation">,</span> fileField<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://example.com/profile/avatar'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  method<span class="token punctuation">:</span> <span class="token string">'PUT'</span><span class="token punctuation">,</span>  body<span class="token punctuation">:</span> formData<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Error:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Success:'</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h4><p>可以通过HTML input type=”file” mutiple 元素，FormData() 和 fetch() 上传文件。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> photos <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"input[type='file'][multiple]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'My Vegas Vacation'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// formData 只接受文件、Blob 或字符串，不能直接传递数组，所以必须循环嵌入</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> photos<span class="token punctuation">.</span>files<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'photo'</span><span class="token punctuation">,</span> photos<span class="token punctuation">.</span>files<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://example.com/posts'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      method<span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>      body<span class="token punctuation">:</span> formData    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Success:'</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Error:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h4 id="检测请求是否成功"><a href="#检测请求是否成功" class="headerlink" title="检测请求是否成功"></a>检测请求是否成功</h4><p>如果遇到网络故障，fetch() promise 将会 reject，带上一个 TypeError 对象。虽然这个情况经常是遇到了权限问题或类似问题——比如 404 不是一个网络故障。想要精确的判断 fetch() 是否成功，需要包含 promise resolved 的情况，此时再判断 Response.ok 是不是为 true。类似以下代码：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'flowers.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">blob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Network response was not ok.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>myBlob<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">var</span> objectURL <span class="token operator">=</span> URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>myBlob<span class="token punctuation">)</span><span class="token punctuation">;</span>       myImage<span class="token punctuation">.</span>src <span class="token operator">=</span> objectURL<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'There has been a problem with your fetch operation: '</span><span class="token punctuation">,</span> error<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h4 id="自定义请求对象"><a href="#自定义请求对象" class="headerlink" title="自定义请求对象"></a>自定义请求对象</h4><p>除了传给 fetch() 一个资源的地址，你还可以通过使用 Request() 构造函数来创建一个 request 对象，然后再作为参数传给 fetch()：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> myHeaders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> myInit <span class="token operator">=</span> <span class="token punctuation">{</span> method<span class="token punctuation">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>               headers<span class="token punctuation">:</span> myHeaders<span class="token punctuation">,</span>               mode<span class="token punctuation">:</span> <span class="token string">'cors'</span><span class="token punctuation">,</span>               cache<span class="token punctuation">:</span> <span class="token string">'default'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> myRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span><span class="token string">'flowers.jpg'</span><span class="token punctuation">,</span> myInit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fetch</span><span class="token punctuation">(</span>myRequest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">blob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>myBlob<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> objectURL <span class="token operator">=</span> URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>myBlob<span class="token punctuation">)</span><span class="token punctuation">;</span>      myImage<span class="token punctuation">.</span>src <span class="token operator">=</span> objectURL<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Request() 和 fetch() 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> anotherRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span>myRequest<span class="token punctuation">,</span>myInit<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个很有用，因为 request 和 response bodies 只能被使用一次（译者注：这里的意思是因为设计成了 stream 的方式，所以它们只能被读取一次）。创建一个拷贝就可以再次使用 request/response 了，当然也可以使用不同的 init 参数。  </p><hr><h4 id="Fetch处理异常、处理其他响应类型"><a href="#Fetch处理异常、处理其他响应类型" class="headerlink" title="Fetch处理异常、处理其他响应类型"></a>Fetch处理异常、处理其他响应类型</h4><p><a href="https://www.cnblogs.com/libin-1/p/6853677.html" target="_blank" rel="noopener">Fetch处理异常、处理其他响应类型</a></p><hr><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">Fetch API</a></p><p><a href="https://www.cnblogs.com/libin-1/p/6853677.html" target="_blank" rel="noopener">使用 Fetch</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记——搜索算法</title>
      <link href="/2019/07/09/sou-suo-suan-fa/"/>
      <url>/2019/07/09/sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="基本搜索算法"><a href="#基本搜索算法" class="headerlink" title="基本搜索算法"></a>基本搜索算法</h3><blockquote><ol><li>枚举算法  <ul><li>列举问题的所有状态从而寻找符合问题的解的方法。  </li><li>适合用于<strong>状态较少，比较简单</strong>的问题上。  </li></ul></li><li>广度优先搜索（BFS）  六度  <ul><li>从初始点开始，根据规则展开第一层节点，并检查目标节点是否在这些节点上，若没有，再将所有的第一层的节点逐一展开，得到第二层节点，如没有，则扩展下去，直到发现目标节点为止。   </li><li>比较适合求<strong>最少步骤或最短解序列</strong>的题目。   </li><li><strong>一般设置一个队列queue</strong>，将起始节点放入队列中，然后从队列头取出一个节点，检查是否是目标节点，如不是则进行扩展，将扩展出的所有节点放到队尾，然后再从队列头取出一个节点，直至找到目标节点。  </li></ul></li><li>深度优先搜索（DFS）  <ul><li><strong>一般设置一个栈stack</strong>，将起始节点放入栈中，然后从栈中弹出一个节点，检查是否是目标节点，如不是则进行扩展，将扩展出的所有节点入栈，然后再从栈顶弹出一个节点，直到找到目标节点。   </li><li><strong>深度优先搜索得到的第一个解，不一定是最优解</strong>。  </li></ul></li><li>A*算法  <ul><li>利用问题的规则和特点来制定一些启发规则，由此来改变节点的扩展顺序，将最有希望扩展出最优解的节点优先扩展，使得尽快找到最优解。  </li><li>对每一个节点，有一个估价函数F来估算起始节点经过该节点到达目标节点的最佳路径的代价。  </li><li><strong>每个节点扩展的时候，总是选择具有最小的F的节点</strong>。  </li><li><strong>F=G+B×H</strong>：G为从起始节点到当前节点的实际代价，已经算出，H为从该节点到目标节点的最优路径的估计代价。F要单调递增。  </li><li>B最好随着搜索深度成反比变化，在搜索深度浅的地方，主要让搜索依靠启发信息，尽快的逼近目标，而当搜索深的时候，逐渐变成广度优先搜索。  </li></ul></li><li>回溯算法  <ul><li>回溯算法是一种系统的搜索问题的解题方法。它的基本思想是：从一条路前行，能进则进，不能进则退回来，换一条路再试。回溯法是一种通用的解题方法  </li><li>和深度优先相似，不同之处在于<strong>对一个节点扩展的时候，并不将所有的子节点扩展出来</strong>，而只扩展其中的一个。因而<strong>具有盲目性，但内存占用少</strong>。 </li></ul></li></ol></blockquote><hr><h3 id="搜索算法优化"><a href="#搜索算法优化" class="headerlink" title="搜索算法优化"></a>搜索算法优化</h3><blockquote><ul><li>在搜索前，根据条件降低搜索规模。   <ul><li>广度优先搜索中，<strong>被处理过的节点，充分释放空间</strong>。    </li><li>根据问题的约束条件进行<strong>剪枝</strong>。   </li><li>利用搜索过程中的中间解，避免重复计算。      </li></ul></li></ul></blockquote><blockquote><ol><li><strong>剪枝</strong>函数<br>对于回溯算法，需要搜索整棵解空间树，剪枝顾名思义，就是通过某种判断，避免一些不必要的遍历过程，剪去解空间树中的一些不必要的枝条，从而缩小整个搜索的规模。  <ol start="2"><li><strong>双向广度搜索</strong><br>所谓双向广度搜索，故名思议指的是搜索沿正向（从初始结点向目标结点方向搜索）和逆向（从目标结点向初始结点方向搜索）两个方向同时进行，当两个方向上的搜索生成同一子结点时完成搜索过程。  <ul><li>从起始节点向目标节点方向搜索，同时从目标节点向起始节点方向搜索。  </li><li>双向搜索<strong>只能用于广度优先搜索</strong>中。    </li><li>双向搜索扩展的<strong>节点数量要比单向少的多</strong>。  </li><li>运用双向广度搜索理想上可以<strong>减少二分之一的搜索量，从而提高搜索效率</strong>。  </li><li>双向广度搜索一般有两种方法：<ul><li>一种是两个方向交替扩展，</li><li>另一种是选择结点个数比较少的方向先扩展。<ul><li>显然第一种方法比第二种方法容易实现，但是由于<strong>第二种方法克服了双向搜索中结点生成速度不平衡的状态，效率将比第一种方法高</strong>。  </li></ul></li></ul></li></ul></li></ol></li></ol></blockquote><hr><h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><ul><li>数的划分<ul><li>对n=m+（n-m），分解时用深搜</li><li>对数m与n-m用回溯递归法搜索。</li></ul></li><li>闪避湖泊<ul><li>深搜</li></ul></li><li>信道分配  <ul><li>构造无向图</li><li>深搜</li></ul></li><li>骑士移动<ul><li>深搜广搜都可，但深搜速度慢量大，广搜效率更高。 </li></ul></li><li>图像周长<ul><li>深搜</li></ul></li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li><a href="http://poj.org/problem?id=1915" target="_blank" rel="noopener">移动的骑士</a></li><li><a href="http://poj.org/problem?id=1426" target="_blank" rel="noopener">寻找M</a></li><li><a href="http://poj.org/problem?id=1979" target="_blank" rel="noopener">红与黑</a></li><li><a href="http://poj.org/problem?id=1011" target="_blank" rel="noopener">小木棒</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie、webstorage（包括sessionStorage、localStorage）、session</title>
      <link href="/2019/07/05/cookie-sessionstorage-localstorage-de-qu-bie/"/>
      <url>/2019/07/05/cookie-sessionstorage-localstorage-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="cookie、webstorage（包括sessionStorage、localStorage）、session"><a href="#cookie、webstorage（包括sessionStorage、localStorage）、session" class="headerlink" title="cookie、webstorage（包括sessionStorage、localStorage）、session"></a>cookie、webstorage（包括sessionStorage、localStorage）、session</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table><thead><tr><th align="center"></th><th align="center">Cookie</th><th align="center">sessionStorage</th><th align="center">localStorage</th><th align="center">session</th></tr></thead><tbody><tr><td align="center"><div style="width: 10pt">数<br>据<br>生<br>命<br>周<br>期</div></td><td align="center"><div style="width: 80pt"> 可自己设置，生成时就会被指定一个maxAge值，这就是cookie的<strong>生存周期</strong>，在这个周期内cookie<strong>有效</strong>，<strong>默认到关闭浏览器时失效</strong></div></td><td align="center"><div style="width: 80pt">（临时保存）页面会话期间可用，<strong>浏览器关闭失效</strong></div></td><td align="center"><div style="width: 80pt">（永久保存）除非自行删除或清除缓存，否则<strong>一直存在</strong></div></td><td align="center"></td></tr><tr><td align="center"><div style="width: 10pt">存<br>放<br>数<br>据<br>大<br>小</div></td><td align="center"><div style="width: 80pt">单个cookie保存的数据不能超过<strong>4kb</strong></div></td><td align="center">5M或更大</td><td align="center">5M或更大</td><td align="center">没有限制</td></tr><tr><td align="center"><div style="width: 10pt"> 存<br>储<br>位<br>置</div></td><td align="center"><div style="width: 80pt">保存在客户端，服务器能够知道其中的信息</div></td><td align="center"><div style="width: 80pt"> 仅在客户端，保存在session对象中</div></td><td align="center"><div style="width: 80pt">仅在客户端，保存在客户端本地的硬件设备，</div></td><td align="center"><div style="width: 80pt">保存在服务器端，客户端不知道其中的信息</div></td></tr><tr><td align="center"><div style="width: 10pt">与<br>服<br>务<br>器<br>间<br>通<br>信</div></td><td align="center"><div style="width: 80pt">在浏览器和服务器间来回传递，每次都会携带在HTTP头中，如果使用Cookie保存过多数据会带来性能问题</div></td><td align="center"><div style="width: 80pt">不参与服务器通信，数据不是由每个服务器请求传递的，只有在请求时使用数据</div></td><td align="center"><div style="width:80pt">不参与服务器通信，数据不是由每个服务器请求传递的，只有在请求时使用数据</div></td><td align="center"></td></tr><tr><td align="center"><div style="width: 10pt"> 易<br>用<br>性</div></td><td align="center"><div style="width: 80pt">Cookie需要自己封装setCookie,getCookie</div></td><td align="center"><div style="width: 80pt"> 拥有setItem,getItem等方法，可以用原生接口，也可以再次封装来对Object和Array有更好的支持</div></td><td align="center"><div style="width: 80pt">拥有setItem,getItem等方法，可以用原生接口，也可以再次封装来对Object和Array有更好的支持</div></td><td align="center"></td></tr><tr><td align="center"><div style="width: 10pt">存<br>储<br>内<br>容<br>类<br>型</div></td><td align="center"><div style="width: 80pt">cookie只能保存字符串类型，以文本的方式</div></td><td align="center"><div style="width: 80pt">只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</div></td><td align="center"><div style="width: 80pt">只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</div></td><td align="center"><div style="width: 80pt">通过类似与Hashtable的数据结构来保存，能支持任何类型的<strong>对象</strong>(session中可含有多个对象)</div></td></tr><tr><td align="center"><div style="width: 10pt">应<br>用<br>场<br>景</div></td><td align="center"><div style="width: 80pt">判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。  保存上次登录的时间等信息。  保存上次查看的页面。  浏览计数。</div></td><td align="center"><div style="width: 80pt">常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据</div></td><td align="center"><div style="width: 80pt">敏感账号一次性登录</div></td><td align="center"><div style="width: 80pt">用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户</div></td></tr><tr><td align="center"><div style="width: 10pt">安<br>全<br>性</div></td><td align="center"><div style="width: 80pt">针对cookie所存在的攻击：Cookie欺骗，Cookie截获</div></td><td align="center"><div style="width: 80pt">高于cookie，不会担心截获，但是仍然存在伪造问题</div></td><td align="center"><div style="width: 80pt">高于cookie，不会担心截获，但是仍然存在伪造问题</div></td><td align="center">高于cookie</td></tr><tr><td align="center"><div style="width: 10pt">作<br>用<br>域</div></td><td align="center"><div style="width: 80pt">在所有同源窗口中都是共享的</div></td><td align="center"><div style="width: 80pt">不在不同的浏览器窗口中共享</div></td><td align="center"><div style="width: 80pt">在所有同源窗口中都是共享的</div></td><td align="center"></td></tr></tbody></table><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>Cookie、sessionStorage、localStorage都是保存在浏览器端，和服务器端的session机制不同。</p><hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="webstorage本地存储"><a href="#webstorage本地存储" class="headerlink" title="webstorage本地存储"></a>webstorage本地存储</h3><ol><li><p>webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage  </p></li><li><p>WebStorage的目标  </p><ul><li>提供一种在cookie之外存储会话数据的路径  </li><li>提供一种存储大量可以跨会话存在的数据的机制    </li></ul></li><li><p>WebStorage的优点：  </p><ul><li>存储空间更大：cookie为4KB，而WebStorage是5MB    </li><li>节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量  </li><li>临时存储：对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便</li><li>快速显示数据：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快  </li><li>安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题  </li><li>WebStorage提供了一些方法，数据操作比cookie方便  <ul><li>setItem (key, value) —— 保存数据，以键值对的方式储存信息。  </li><li>getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。  </li><li>removeItem (key) —— 删除单个数据，根据键值移除对应的信息。  </li><li>clear () —— 删除所有的数据  </li><li>key (index) —— 获取某个索引的key  </li></ul></li></ul></li></ol><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><ol><li>sessionStorage是Storage类型的一个对象，拥有clear(),getItem(name),key(index),removeItem(name),setItem(name,value)方法  </li><li>sessionStorage对象存储特定于某个会话的数据,也就是该数据只保持到浏览器关闭  </li><li>将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据  </li><li>sessionStorage为临时保存  </li></ol><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><ol><li>localStorage也是Storage类型的一个对象  </li><li>在HTML5中localStorage作为持久保存在客户端数据的方案取代了globalStorage(globalStorage必须指定域名)  </li><li>localStorage会永久存储会话数据，除非removeItem,否则会话数据一直存在  </li><li>将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用  </li><li>localStorage为永久保存   </li></ol><h5 id="webstorage读写数据时使用的基本方法"><a href="#webstorage读写数据时使用的基本方法" class="headerlink" title="webstorage读写数据时使用的基本方法"></a>webstorage读写数据时使用的基本方法</h5><ol><li><p>sessionStorage</p><ul><li><p>保存数据的方法：  </p><pre class=" language-javascript"><code class="language-javascript">sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或者写成</span>sessionStorage<span class="token punctuation">.</span>key<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">;</span></code></pre></li><li><p>读取数据的方法：</p><pre class=" language-javascript"><code class="language-javascript">变量<span class="token operator">=</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或者写成</span>变量<span class="token operator">=</span>sessionStorage<span class="token punctuation">.</span>key<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>localStorage</p><ul><li><p>保存数据的方法：</p><pre class=" language-javascript"><code class="language-javascript">localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或者写成</span>localStorage<span class="token punctuation">.</span>key<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">;</span></code></pre></li><li><p>读取数据的方法：</p><pre class=" language-javascript"><code class="language-javascript">变量<span class="token operator">=</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或者写成</span>变量<span class="token operator">=</span>localStorage<span class="token punctuation">.</span>key<span class="token punctuation">;</span></code></pre></li></ul></li></ol><p>在保存数据时，若使用<strong>sessionStorage</strong>读取或保存数据，则使用<strong>sessionStorage对象</strong> 并调用该对象的读写方法；若使用<strong>localStorage</strong>读取或保存数据，则使用<strong>localStorage</strong>对象并调用该对象的读写方法。    </p><p>在进行读写时，不管是哪个对象，都可以通过该对象的<strong>getItem方法来读取数据</strong>，也可以该对象的<strong>自定义属性值读取数据</strong>；可以通过该对象的<strong>setItem方法保存数据</strong>，也可以通过该对象的<strong>自定义属性值保存数据</strong>。  </p><p>保存数据时<strong>按“键名/键值”的形式</strong>进行保存。  </p><ul><li>当通过该对象的getItem方法读取数据时，将参数指定为键名，该方法返回键值；当通过该对象的自定义属性值读取数据时，可以将该对象的某个自定义属性名作为键名，访问该自定义属性的属性值即可得到键值；  </li><li>当通过该对象的setItem方法保存数据时，将第一个参数指定为键名，将第二个参数指定为键值；当通过该对象的自定义属性值保存数据时，可以将该对象的某个自定义属性名作为键名，然后直接将该自定义属性值设置为键值。 </li><li>在保存数据时不允许重复保存相同的键名。保存后可以修改键值，但不允许修改键名(只能重新取键名，然后再保存键值)。</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ol><li><p>HTTP Cookie简称cookie,在HTTP请求发送Set-Cookie HTTP头作为响应的一部分。通过name=value的形式存储  </p></li><li><p>cookie的构成：  </p><ul><li>名称：name(不区分大小写,但最好认为它是区分的)  </li><li>值:value(通过URL编码:encodeURIComponent)  </li><li>域  </li><li>路径  </li><li>失效时间:一般默认是浏览器关闭失效,可以自己设置失效时间  </li><li>安全标志:设置安全标志后只有SSL连接的时候才发送到服务器    </li></ul></li><li><p>cookie的作用:主要用于保存登录信息  </p></li><li><p>生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题  </p></li><li><p>cookie的优点：  </p><ul><li>具有极高的扩展性和可用性  </li><li>通过良好的编程，控制保存在cookie中的session对象的大小  </li><li>通过加密和安全传输技术，减少cookie被破解的可能性  </li><li>只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失  </li><li>控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie  </li></ul></li><li><p>cookie的缺点：  </p><ul><li>cookie的长度和数量大小受限。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉  </li><li>安全性较低。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用</li><li>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用  </li><li>用户可以操作（禁用）cookie，使功能受限</li><li>每次访问都要传送cookie给服务器，浪费带宽。</li><li>cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。而session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。</li></ul></li></ol><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><ol><li>session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。</li><li>缺点：  <ul><li>Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</li><li>依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全</li><li>创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。  </li></ul></li></ol><hr><h2 id="区别的比较"><a href="#区别的比较" class="headerlink" title="区别的比较"></a>区别的比较</h2><h3 id="本地储存localStorage与cookie的区别"><a href="#本地储存localStorage与cookie的区别" class="headerlink" title="本地储存localStorage与cookie的区别"></a>本地储存localStorage与cookie的区别</h3><pre class=" language-c"><code class="language-c">    <span class="token number">1</span>）cookie在浏览器与服务器之间来回传递    sessionStorage和localStorage不会把数据发给服务器，仅在本地保存    <span class="token number">2</span>）数据有效期不同    cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭    sessionStorage：仅在当前浏览器窗口关闭前有效    localStorage 始终有效，长期保存    <span class="token number">3</span>）cookie数据还有路径的概念，可以限制cookie只属于某个路径下    存储大小也不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大    <span class="token number">4</span>）作用域不用    sessionStorage不在不同的浏览器窗口中共享    localStorage在所有同源窗口中都是共享的    cookie也是在所有同源窗口中都是共享的    WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便</code></pre><h3 id="cookie、session和localStorage的区别"><a href="#cookie、session和localStorage的区别" class="headerlink" title="cookie、session和localStorage的区别"></a>cookie、session和localStorage的区别</h3><pre class=" language-c"><code class="language-c">    <span class="token number">1</span>）cookie的内容主要包括：名字、值、过期时间、路径和域，路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失，这种生命期为浏览器会话期的cookie被称为会话cookie    <span class="token number">2</span>）会话cookie一般不存储在硬盘而是保存在内存里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。    <span class="token number">3</span>）当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</code></pre><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><pre class=" language-c"><code class="language-c">    <span class="token number">1</span>）cookie数据存放在客户的浏览器上，session数据放在服务器上    <span class="token number">2</span>）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session    <span class="token number">3</span>）session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie    <span class="token number">4</span>）单个cookie保存的数<span class="token operator">*</span>据不能超过4K，很多浏览器都限制一个站点最多保存<span class="token number">20</span>个cookie    <span class="token number">5</span>）建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中    <span class="token number">6</span>）session保存在服务器，客户端不知道其中的信心；cookie保存在客户端，服务器能够知道其中的信息    <span class="token number">7</span>）session中保存的是对象，cookie中保存的是字符串    <span class="token number">8</span>）session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的</code></pre><h3 id="web-Storage和cookie的区别"><a href="#web-Storage和cookie的区别" class="headerlink" title="web Storage和cookie的区别"></a>web Storage和cookie的区别</h3><pre class=" language-c"><code class="language-c">    <span class="token number">1</span>）Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用    <span class="token number">2</span>）web storage拥有setItem<span class="token punctuation">,</span>getItem<span class="token punctuation">,</span>removeItem<span class="token punctuation">,</span>clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie    <span class="token number">3</span>）但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生    sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的    <span class="token number">4</span>）Web Storage的好处    减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递    快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示    临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便</code></pre><h3 id="浏览器本地存储与服务器端存储的区别"><a href="#浏览器本地存储与服务器端存储的区别" class="headerlink" title="浏览器本地存储与服务器端存储的区别"></a>浏览器本地存储与服务器端存储的区别</h3><pre class=" language-c"><code class="language-c">    <span class="token number">1</span>）数据既可以在浏览器本地存储，也可以在服务器端存储    <span class="token number">2</span>）浏览器可以保存一些数据，需要的时候直接从本地存取，sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据    <span class="token number">3</span>）服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据    <span class="token number">4</span>）服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端 ，服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上    <span class="token number">5</span>）服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象，会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期    <span class="token number">6</span>）服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些，浏览器只适合存储一般数据</code></pre><h3 id="sessionStorage、localStorage和cookie的区别"><a href="#sessionStorage、localStorage和cookie的区别" class="headerlink" title="sessionStorage、localStorage和cookie的区别"></a>sessionStorage、localStorage和cookie的区别</h3><pre class=" language-c"><code class="language-c">    <span class="token number">1</span>）相同点是都是保存在浏览器端、且同源的    <span class="token number">2</span>）cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下    <span class="token number">3</span>）存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大    <span class="token number">4</span>）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭    <span class="token number">5</span>）作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的    <span class="token number">6</span>）web Storage支持事件通知机制，可以将数据更新的通知发送给监听者    <span class="token number">7</span>）web Storage的api接口使用更方便</code></pre><h3 id="sessionStorage与页面js数据对象的区别"><a href="#sessionStorage与页面js数据对象的区别" class="headerlink" title="sessionStorage与页面js数据对象的区别"></a>sessionStorage与页面js数据对象的区别</h3><pre class=" language-c"><code class="language-c">    <span class="token number">1</span>）页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了    <span class="token number">2</span>）sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在</code></pre><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://www.cnblogs.com/pengc/p/8714475.html" target="_blank" rel="noopener">cookies、sessionStorage和localStorage解释及区别</a> </p><p><a href="https://blog.csdn.net/weixin_42614080/article/details/90706499" target="_blank" rel="noopener">cookie、sessionStorage和localStorage的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常用</title>
      <link href="/2019/07/05/qian-duan-chang-yong/"/>
      <url>/2019/07/05/qian-duan-chang-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><p><a href="http://www.h-ui.net/site.shtml" target="_blank" rel="noopener">前端网址导航 - H-ui前端框架官方网站</a></p></li><li><p><a href="https://www.bootcss.com/" target="_blank" rel="noopener">Bootstrap中文网</a></p></li><li><p><a href="https://www.w3school.com.cn/index.html" target="_blank" rel="noopener">w3school</a></p></li><li><p><a href="https://www.youzhan.org/page/2/" target="_blank" rel="noopener">Bootstrap 网页精选</a></p></li><li><p><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴矢量图标库</a></p></li></ul><hr><h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><a href="http://bg-patterns.com/?paged=36" target="_blank" rel="noopener">Bg-patterns 背景パターン配布＆作成サイト </a> </li></ul><h3 id="插画"><a href="#插画" class="headerlink" title="插画"></a>插画</h3><ul><li><a href="https://iradesign.io/gallery/illustrations" target="_blank" rel="noopener">IRA Design</a> </li><li><a href="https://undraw.co/illustrations" target="_blank" rel="noopener">Undraw</a></li><li><a href="https://www.glazestock.com/" target="_blank" rel="noopener">Glaze</a></li><li><a href="https://airtable.com/" target="_blank" rel="noopener">Airtable</a> (插画插件)</li></ul><hr><h2 id="logo制作"><a href="#logo制作" class="headerlink" title="logo制作"></a>logo制作</h2><ul><li><a href="https://www.canva.com/" target="_blank" rel="noopener">canva</a> （常用、中文、免费）</li><li><a href="https://www.graphicsprings.com/zh" target="_blank" rel="noopener">graphicsprings</a>（免费、每日更新）</li><li><a href="https://www.ucraft.com/free-logo-maker" target="_blank" rel="noopener">ucraft</a> （免费、高分辨率）</li><li><a href="https://hatchful.shopify.com/" target="_blank" rel="noopener">hatchful</a></li><li><a href="https://www.designhill.com/tools/logo-maker" target="_blank" rel="noopener">designhill</a>（免费）</li><li><a href="https://www.tailorbrands.com/" target="_blank" rel="noopener">tailorbrands</a> （快速设计）</li><li><a href="https://www.logogarden.com/" target="_blank" rel="noopener">logogarden</a>（快速设计）</li><li><a href="https://www.logogenie.net/" target="_blank" rel="noopener">logogenie</a> （免费、快速设计）</li></ul><hr><h2 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h2><ul><li><a href="https://www.iconfont.cn/collections/detail?cid=16265" target="_blank" rel="noopener">黄色小图标1</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16257" target="_blank" rel="noopener">黄色小图标2</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16317" target="_blank" rel="noopener">黄色小图标3</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16393" target="_blank" rel="noopener">蓝色小图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16539" target="_blank" rel="noopener">蓝色小图标·CRM_icon</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16649" target="_blank" rel="noopener">蓝色小图标·企业组织专用图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=16150" target="_blank" rel="noopener">紫色小图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16505" target="_blank" rel="noopener">紫色小图标·娱乐类线性图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16717" target="_blank" rel="noopener">灰色小图标1</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16740" target="_blank" rel="noopener">灰色小图标2</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16749" target="_blank" rel="noopener">灰色小图标·音乐</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16754" target="_blank" rel="noopener">灰色小图标·吃货大收集</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16814" target="_blank" rel="noopener">灰色小图标·天气</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16880" target="_blank" rel="noopener">灰色小图标·供应链平台</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=15672" target="_blank" rel="noopener">彩色通讯线性图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=16240" target="_blank" rel="noopener">彩色工作图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=16147" target="_blank" rel="noopener">彩色智能科技图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=16458" target="_blank" rel="noopener">彩色商业金融类扁平图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16468" target="_blank" rel="noopener">彩色金融营销图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16470" target="_blank" rel="noopener">彩色卡通警示类图标</a></li></ul><hr><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p><a href="http://www.divcss5.com/rumen/r403.shtml" target="_blank" rel="noopener">CSS position绝对定位absolute relative</a></p></li><li><p><a href="https://www.html5tricks.com/css3-hyperlink-animation.html" target="_blank" rel="noopener">CSS3自定义样式超链接按钮 鼠标滑过带动画特效</a>  </p></li><li><p><a href="https://www.html5tricks.com/css3-3d-svg-button.html" target="_blank" rel="noopener">3D质感CSS3按钮 按钮内容支持SVG</a></p></li><li><p><a href="https://www.html5tricks.com/pure-css3-switch-radio.html" target="_blank" rel="noopener">纯CSS3开关样式的自定义单选框</a>  </p></li></ul><hr><h2 id="设计风格"><a href="#设计风格" class="headerlink" title="设计风格"></a>设计风格</h2><ul><li><p><a href="https://www.atlassian.com/time-wasting-at-work-infographic" target="_blank" rel="noopener">You Waste A Lot Of Time At Work</a></p></li><li><p><a href="http://www.qinxue.com/284.html?sysref=2d5" target="_blank" rel="noopener">2.5D插画入门与进阶教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常用</title>
      <link href="/2019/07/05/chang-yong-han-shu-yu-zhu-yi-shi-xiang/"/>
      <url>/2019/07/05/chang-yong-han-shu-yu-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bits/stdc++.h"</span> </span>using namespace std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span>   </span><span class="token comment" spellcheck="true">//C++ </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">//C</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> </span><span class="token comment" spellcheck="true">//含有将字符串整数相互转换的函数</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span> </span><span class="token comment" spellcheck="true">//sort()</span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>多组输入输出  </li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>数组所有数置零  </li></ul><pre class=" language-c"><code class="language-c"><span class="token function">memset</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><ul><li>去多余字符  </li></ul><pre class=" language-c"><code class="language-c"><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><ul><li>字符处理函数  </li></ul><pre class=" language-c"><code class="language-c">在ctype<span class="token punctuation">.</span>h头文件中<span class="token keyword">int</span> <span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断c是否是数字字符，是则返回1，否则返回0，下同。</span><span class="token keyword">int</span> <span class="token function">isalpha</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断c是否是一个字母</span><span class="token keyword">int</span> <span class="token function">isalnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断c是否是一个数字或字母</span><span class="token keyword">int</span> <span class="token function">islower</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断c是否是一个小写字母</span><span class="token keyword">int</span> <span class="token function">isupper</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断c是否是一个大写字母</span><span class="token keyword">int</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果c是一个小写字母，则返回其大写字母</span><span class="token keyword">int</span> <span class="token function">tolower</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果c是一个大写字母，则返回其小写字母</span></code></pre><ul><li>字符串和内存操作函数  </li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将字符串s1内容拷贝到s2</span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将字符串s1拷贝到s1,但最多拷贝n个字节。若拷贝字节数达到n，就不会往s1中写入结尾的'\0'</span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strcat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将s2添加到s1末尾</span><span class="token comment" spellcheck="true">//        </span><span class="token keyword">int</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//比较两字符串，大小写相关。返回值&lt;0，则s1按字典顺序在s2前。返回值=0，字符串一样。返回值>0，s1在s2后。</span><span class="token keyword">int</span> <span class="token function">stricmp</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//比较两字符串，大小写无关。返回值&lt;0，则s1按字典顺序在s2前。返回值=0，字符串一样。返回值>0，s1在s2后。  </span><span class="token keyword">int</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//计算字符串长度</span><span class="token comment" spellcheck="true">//       </span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strncat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strDestination<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strSource<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将字符串前count个字符添加到字符串strDestination末尾</span><span class="token comment" spellcheck="true">//  </span><span class="token keyword">int</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string2<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//分别取两个字符串的前count个字符作为子字符串，比较大小。</span><span class="token comment" spellcheck="true">//      </span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strrev</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将字符串string前后颠倒</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>s2 <span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将s2处的n字节拷贝到s1</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将s开始的n个字节全部置c  </span></code></pre><ul><li>字符串与数相互转换的函数（定义在stdlib.h中）  </li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">atoi</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//字符串s内容转为整型数返回，s="1234",返回1234</span><span class="token keyword">double</span> <span class="token function">atof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//字符串s转为浮点数</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">itoa</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>string <span class="token punctuation">,</span><span class="token keyword">int</span> radix<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//整数value以radix进制表写入string</span></code></pre><ul><li><p><a href="https://blog.csdn.net/vir_lee/article/details/80560236" target="_blank" rel="noopener">C++学习之sort（），partial_sort()和partial_sort_copy()的使用与注意事项</a></p></li><li><p><a href="https://blog.csdn.net/AFishhhhhh/article/details/79980359" target="_blank" rel="noopener">C++ vector&amp; nums 用法一</a></p></li><li><p><a href="https://blog.csdn.net/cai_niaocainiao/article/details/81260902" target="_blank" rel="noopener">C++ replace() 函数用法</a></p></li><li><p><a href="https://blog.csdn.net/albertsh/article/details/96162344" target="_blank" rel="noopener">C++自定义全部替换函数replace</a></p></li><li><p><a href="https://blog.csdn.net/qq_33933704/article/details/79188028" target="_blank" rel="noopener">c++处理字符串string.find()与string::npos</a></p></li></ul><h3 id="常用缩写"><a href="#常用缩写" class="headerlink" title="常用缩写"></a>常用缩写</h3><table><thead><tr><th>原词</th><th align="center">缩写</th><th align="center">原词</th><th align="center">缩写</th><th align="center">原词</th><th align="right">缩写</th></tr></thead><tbody><tr><td>absolute</td><td align="center">abs</td><td align="center">error</td><td align="center">err</td><td align="center">operator</td><td align="right">optr</td></tr><tr><td>addition</td><td align="center">add</td><td align="center">float</td><td align="center">flt</td><td align="center">packet</td><td align="right">pkt</td></tr><tr><td>adjust</td><td align="center">adj</td><td align="center">form</td><td align="center">frm</td><td align="center">position</td><td align="right">pos</td></tr><tr><td>answer</td><td align="center">ans</td><td align="center">four</td><td align="center">4</td><td align="center">previous</td><td align="right">pre或prev</td></tr><tr><td>array</td><td align="center">arr</td><td align="center">frequency</td><td align="center">freq</td><td align="center">payload type</td><td align="right">pt</td></tr><tr><td>average</td><td align="center">avg</td><td align="center">function</td><td align="center">fun</td><td align="center">pointer</td><td align="right">ptr</td></tr><tr><td>buffer</td><td align="center">buf或buff</td><td align="center">header</td><td align="center">hdr</td><td align="center">return code</td><td align="right">rc</td></tr><tr><td>capture</td><td align="center">cap或capt</td><td align="center">index</td><td align="center">idx</td><td align="center">record</td><td align="right">rcd</td></tr><tr><td>check</td><td align="center">chk</td><td align="center">image</td><td align="center">img</td><td align="center">receive</td><td align="right">recv</td></tr><tr><td>count</td><td align="center">cnt</td><td align="center">increment</td><td align="center">inc</td><td align="center">result</td><td align="right">res</td></tr><tr><td>column</td><td align="center">col</td><td align="center">initialize</td><td align="center">init</td><td align="center">return</td><td align="right">ret</td></tr><tr><td>compare</td><td align="center">cmp</td><td align="center">iteration</td><td align="center">itr</td><td align="center">source</td><td align="right">src</td></tr><tr><td>control</td><td align="center">ctrl</td><td align="center">length</td><td align="center">len</td><td align="center">stack</td><td align="right">stk</td></tr><tr><td>decode</td><td align="center">dec</td><td align="center">memory</td><td align="center">mem</td><td align="center">string</td><td align="right">str</td></tr><tr><td>define</td><td align="center">def</td><td align="center">middle</td><td align="center">mid</td><td align="center">subtraction</td><td align="right">sub</td></tr><tr><td>delete</td><td align="center">del</td><td align="center">make</td><td align="center">mk</td><td align="center">table</td><td align="right">tab</td></tr><tr><td>destination</td><td align="center">dst或dest</td><td align="center">message</td><td align="center">msg</td><td align="center">temporary</td><td align="right">tmp或temp</td></tr><tr><td>display</td><td align="center">disp</td><td align="center">multiplication</td><td align="center">mul</td><td align="center">to</td><td align="right">2</td></tr><tr><td>division</td><td align="center">div</td><td align="center">number</td><td align="center">num</td><td align="center">total</td><td align="right">tot</td></tr><tr><td>encode</td><td align="center">enc</td><td align="center">operand</td><td align="center">opnd</td><td align="center">time stamp</td><td align="right">ts</td></tr><tr><td>environment</td><td align="center">env</td><td align="center">optimization</td><td align="center">opt</td><td align="center">value</td><td align="right">val</td></tr></tbody></table><hr><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>用空指针尽可能的使用nullptr。<br><a href="https://blog.csdn.net/znzxc/article/details/80354434" target="_blank" rel="noopener">NULL与nullptr</a></p></li><li><p>太大的数定义在main外</p></li></ul><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> N 10010</span><span class="token keyword">int</span> cnt<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><ul><li><p>高精度计算  </p><ul><li>有符号整数（int）能表示的范围是-263－263– 1，即-9223372036854775808~ 9223372036854775807。</li><li>无符号整数（unsigned int）类型能表示的范围是0－264– 1，即0~18446744073709551615。</li><li>因此int和unsigned类型变量，都不能保存超过<strong>19位</strong>的整数。  </li><li>数组存储：数组unsigned an[201]来保存一个200位的整数，让an[0]存放个位，an[1]存十位，……</li></ul></li><li><p>其它</p><ul><li><p>%-7d  右对齐显示7位</p></li><li><p>t1=t1&lt;&lt;1;  //“&lt;&lt;”左移即乘2，时间复杂度比用“ * ”更快  </p></li><li><p>a[i]=1-a[i] //0&lt;=&gt;1</p></li><li><p>把一个数加0.5再int,可实现四舍五入</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发赛记录</title>
      <link href="/2019/04/05/wei-xin-xiao-cheng-xu-kai-fa-sai-ji-lu/"/>
      <url>/2019/04/05/wei-xin-xiao-cheng-xu-kai-fa-sai-ji-lu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h2><ul><li><p><a href="https://www.imooc.com/learn/795" target="_blank" rel="noopener">axure软件学习课程</a>  </p></li><li><p>原型旁写上操作说明和数据来源、输出结果等信息。</p></li><li><p>微信小程序没有限制5层（<a href="https://segmentfault.com/a/1190000012282464" target="_blank" rel="noopener">微信小程序页面5层限制的一种解决方案</a>），但设计产品的时候，尽量不要进入超过5层，超过了5层，这个产品容易出现问题。</p></li><li><p>Mark Man标注颜色、尺寸</p></li></ul><hr><h2 id="小程序端"><a href="#小程序端" class="headerlink" title="小程序端"></a>小程序端</h2><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><ul><li>使用Color-UI组件库</li></ul><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul><li>引导页</li><li>导航栏:利用navigator组件导航跳转，自定义底部导航栏tarbar样式，并隐藏系统tarBar组件。（自定义封装组件component的好处：各个tarbar页只需调用editTarbar、调用组件即可）</li><li>搜索记录盒子、记录词盒子中词的增加删除：利用数据绑定以及获取缓存，获取历史搜索值，并清空历史搜索值。</li><li>实现指定内容的收藏与取消收藏：longTap事件监听用户是否进行长按，再利用缓存及数据绑定，实现收藏与取消收藏。</li><li>实现滑动选择背景图：使用scroll-view可滚动视图组件。</li><li>用canvas自定义绘图，绘制指定内容(句子信息以及小程序推广二维码)，调用小程序官方API wx.saveImageToPhotosAlbum将图片保存到本地。</li><li>由于canvas绘制过长文字时不会自动换行，因此需要处理文本换行问题，调用drawText。</li><li>调用官方APIcanvasToTempFilePath，将绘制好的图片保存为图片(png类型)（对像素比处理，防止图片模糊）</li><li>利用swiper组件实现滑动切换选项卡操作，利用当前页面currentData，显示对应页面，对应页面为swiper-item内的内容。</li><li>利用模板template生成模板，简易修改。</li><li>通过数据绑定，实现选择菜单后的数据显示，逻辑判断当前菜单选择的数据，更新前端数据current_name。</li><li>小程序右上角转发消息函数onShareAppMessage，自定义转发消息</li><li><a href="https://www.jianshu.com/p/7ad22e35b556" target="_blank" rel="noopener">微信小程序：长按点击事件实现</a></li><li><a href="https://www.jianshu.com/p/96150ed09e3a" target="_blank" rel="noopener">微信小程序实现同时单击、双击、长按</a></li><li><a href="http://www.yiyongtong.com/archives/view-286-1.html" target="_blank" rel="noopener">小程序长按事件触发点击事件的BUG处理</a></li><li><a href="https://www.cnblogs.com/laiqiangjin/p/8963133.html" target="_blank" rel="noopener">小程序的长按事件和点击事件</a></li></ul><hr><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li>bmob后端云做数据存储管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树、B+树、B*树</title>
      <link href="/2018/04/09/b-shu-b-shu-b-cheng-shu/"/>
      <url>/2018/04/09/b-shu-b-shu-b-cheng-shu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="B树、B-树、B-树"><a href="#B树、B-树、B-树" class="headerlink" title="B树、B+树、B*树"></a>B树、B+树、B*树</h1><hr><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><ul><li>B树：二叉树 ，有序数组+平衡多叉树；  </li><li>B-树：是一种多路搜索树   </li><li>B+树：B+树是B-树的变体，也是一种多路搜索树。非叶子结点的子树指针与关键字个数相同，有序数组链表+平衡多叉树；  </li><li>B*树：一棵丰满的B+树。是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</li></ul><hr><ol><li><ul><li>B+树<strong>方便扫库</strong>  </li><li>B树必须用<strong>中序遍历</strong>的方法按序扫库<br>B+树直接从叶子结点挨个扫一遍就完了  </li></ul></li><li><ul><li>B+树支持 <strong>range-query（范围查询）</strong>非常方便，而B树不支持。这是数据库选用B+树的最主要原因。<br>比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。  </li><li>B树的好处，就是<strong>成功查询</strong>特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。<br>B树比如你的例子中查，17，一把就得到结果了，<br>有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。</li></ul></li></ol><hr><ul><li>B树比连续内存空间的二分查找的优点是，改变B树结构(插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销</li><li>B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引B+-tree的查询效率更加稳定</li><li>B*树分配新结点的概率比B+树要低，空间使用率更高</li></ul><hr><p>B树<br><img src="/2018/04/09/b-shu-b-shu-b-cheng-shu/1.jpg" alt="B树">      </p><p>B+树<br><img src="/2018/04/09/b-shu-b-shu-b-cheng-shu/2.jpg" alt="B+树">   </p><p>B*树     </p><p><img src="/2018/04/09/b-shu-b-shu-b-cheng-shu/3.jpg" alt="B*树"></p><hr><h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><blockquote><p>B 树又叫平衡多路查找树。一棵m阶的B 树 (注：切勿简单的认为一棵m阶的B树是m叉树，虽然存在四叉树，八叉树，KD树，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同)的特性如下：</p></blockquote><blockquote><ol><li><strong>树中每个结点最多含有m个孩子（m&gt;=2）</strong>；  </li><li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；  </li><li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；  </li><li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；（读者反馈@冷岳：这里有错，叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。@研究者July：其实，关键是把什么当做叶子结点，因为如红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。  </li><li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。<br>b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。<br>c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</li></ol></blockquote><blockquote><p><strong>B树的高度</strong><br><strong>(┌M/2┐是向上取整,即取与结果最接近的比结果大的整数,┌3/2┐=2； └M/2┘是向下取整,即取与结果最接近的比结果小的整数,└3/2┘=1.)</strong>  </p></blockquote><blockquote><ol><li>因为根至少有两个孩子，因此第2层至少有两个结点。  </li><li>除根和叶子外，其它结点至少有┌m/2┐个孩子，  </li><li>因此在第3层至少有2*┌m/2┐个结点，  </li><li>在第4层至少有2*(┌m/2┐^2)个结点，  </li><li>在第 I 层至少有2<em>(┌m/2┐^(l-2) )个结点，于是有： N+1 ≥ 2</em>┌m/2┐I-2；  </li><li>考虑第L层的结点个数为N+1，那么2*(┌m/2┐^(l-2)）≤N+1，也就是L层的最少结点数刚好达到N+1个，即： I≤ log┌m/2┐((N+1)/2 )+2；<br>所以   </li></ol><p><strong>当B树包含N个关键字时，B树的最大高度为l-1（因为计算B树高度时，叶结点所在层不计算在内），即：l - 1 = log┌m/2┐((N+1)/2 )+1.</strong><br>这个B树的高度公式从侧面显示了B树的查找效率是相当高的。<br><strong>一棵含有N个总关键字数的m阶的B树的最大高度是多少?<br>答：log_ceil（m/2）(N+1)/2 + 1 （上面中关于m阶B树的第1点特性已经提到：树中每个结点含有最多含有m个孩子，即m满足：ceil(m/2)&lt;=m&lt;=m。而树中每个结点含孩子数越少，树的高度则越大，故如此）。</strong></p></blockquote><hr><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><blockquote><p>B+tree：是应文件系统所需而产生的一种<strong>Btree的变形树</strong>。<br>一棵m阶的B+树和m阶的B树的异同点在于：<br>1.<strong>有n棵子树的结点中含有n-1 个关键字</strong>； (此处颇有争议，B+树到底是与B 树n棵子树有n-1个关键字 保持一致，还是不一致： <strong>B树n棵子树的结点中含有n个关键字</strong>，待后续查证。<br>2.<strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 <strong>(而B 树的叶子节点并没有包括全部需要查找的信息)</strong><br>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p></blockquote><hr><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><blockquote><p>B* -tree是<strong>B+-tree的变体</strong>，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B* 树中<strong>非根和非叶子结点再增加指向兄弟的指针</strong>；B* 树定义了非叶子结点关键字个数至少为(2/3)* M，即<strong>块的最低使用率为2/3（代替B+树的1/2）</strong>。  </p></blockquote><blockquote><p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。<br>B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。<br>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p></blockquote><hr><p>内容参考/更多B-tree插入删除操作见<br><a href="https://blog.csdn.net/u013400245/article/details/52824744" target="_blank" rel="noopener">B树B+树的原理和操作</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
