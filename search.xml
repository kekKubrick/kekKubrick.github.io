<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020电影札记</title>
      <link href="/2020/04/09/dian-ying-zha-ji/"/>
      <url>/2020/04/09/dian-ying-zha-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我喜爱的电影导演"><a href="#我喜爱的电影导演" class="headerlink" title="我喜爱的电影导演"></a>我喜爱的电影导演</h2><ul><li>Stanley Kubrick</li><li>徐克</li><li>王家卫</li><li>Christopher Nolan</li><li>忻钰坤</li></ul><h2 id="我喜爱的电影"><a href="#我喜爱的电影" class="headerlink" title="我喜爱的电影"></a>我喜爱的电影</h2><ul><li>美丽人生</li><li>巴里·林登</li><li>东邪西毒 </li><li>末代皇帝</li><li>2001太空漫游 </li><li>万物理论</li><li>敦刻尔克</li><li>奇爱博士</li><li>思悼</li><li>杀人回忆</li><li>坠入 </li><li>全金属外壳</li><li>大话西游之月光宝盒</li><li>大话西游之大圣娶亲</li><li>梁祝</li></ul><h2 id="我喜爱的导演混剪-影片分析-采访"><a href="#我喜爱的导演混剪-影片分析-采访" class="headerlink" title="我喜爱的导演混剪/影片分析/采访"></a>我喜爱的导演混剪/影片分析/采访</h2><p><a href="https://www.bilibili.com/video/BV147411r7DA" target="_blank" rel="noopener">库布里克&amp;塔科夫斯基镜头对比</a></p><p><a href="https://www.xinpianchang.com/a52439?from=search_post" target="_blank" rel="noopener">娄烨导演电影混剪</a></p><p><a href="https://www.bilibili.com/video/BV1ps411P7h2" target="_blank" rel="noopener">徐克专访</a></p><p><a href="https://www.bilibili.com/video/BV1ub411a7ai" target="_blank" rel="noopener">盖里奇电影混剪</a></p><p><a href="https://www.bilibili.com/video/BV1uJ41157wV" target="_blank" rel="noopener">《敦刻尔克》结构性剪辑</a></p>]]></content>
      
      
      <categories>
          
          <category> 电影札记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影札记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树、B+树、B*树</title>
      <link href="/2020/04/09/b-shu-b-shu-b-cheng-shu/"/>
      <url>/2020/04/09/b-shu-b-shu-b-cheng-shu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="B树、B-树、B-树"><a href="#B树、B-树、B-树" class="headerlink" title="B树、B+树、B*树"></a>B树、B+树、B*树</h1><hr><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><ul><li>B树：二叉树 ，有序数组+平衡多叉树；  </li><li>B-树：是一种多路搜索树   </li><li>B+树：B+树是B-树的变体，也是一种多路搜索树。非叶子结点的子树指针与关键字个数相同，有序数组链表+平衡多叉树；  </li><li>B*树：一棵丰满的B+树。是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</li></ul><hr><ol><li><ul><li>B+树<strong>方便扫库</strong>  </li><li>B树必须用<strong>中序遍历</strong>的方法按序扫库<br>B+树直接从叶子结点挨个扫一遍就完了  </li></ul></li><li><ul><li>B+树支持 <strong>range-query（范围查询）</strong>非常方便，而B树不支持。这是数据库选用B+树的最主要原因。<br>比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。  </li><li>B树的好处，就是<strong>成功查询</strong>特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。<br>B树比如你的例子中查，17，一把就得到结果了，<br>有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。</li></ul></li></ol><hr><ul><li>B树比连续内存空间的二分查找的优点是，改变B树结构(插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销</li><li>B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引B+-tree的查询效率更加稳定</li><li>B*树分配新结点的概率比B+树要低，空间使用率更高</li></ul><hr><p>B树<br><img src="/2020/04/09/b-shu-b-shu-b-cheng-shu/1.jpg" alt="B树">      </p><p>B+树<br><img src="/2020/04/09/b-shu-b-shu-b-cheng-shu/2.jpg" alt="B+树">   </p><p>B<em>树<br>![B</em>树](3.jpg)</p><hr><h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B 树又叫平衡多路查找树。一棵m阶的B 树 (注：切勿简单的认为一棵m阶的B树是m叉树，虽然存在四叉树，八叉树，KD树，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同)的特性如下：</p><ol><li><strong>树中每个结点最多含有m个孩子（m&gt;=2）</strong>；  </li><li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；  </li><li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；  </li><li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；（读者反馈@冷岳：这里有错，叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。@研究者July：其实，关键是把什么当做叶子结点，因为如红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。  </li><li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。<br>b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。<br>c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</li></ol><p><strong>B树的高度</strong><br><strong>(┌M/2┐是向上取整,即取与结果最接近的比结果大的整数,┌3/2┐=2； └M/2┘是向下取整,即取与结果最接近的比结果小的整数,└3/2┘=1.)</strong>  </p><ol><li>因为根至少有两个孩子，因此第2层至少有两个结点。  </li><li>除根和叶子外，其它结点至少有┌m/2┐个孩子，  </li><li>因此在第3层至少有2*┌m/2┐个结点，  </li><li>在第4层至少有2*(┌m/2┐^2)个结点，  </li><li>在第 I 层至少有2<em>(┌m/2┐^(l-2) )个结点，于是有： N+1 ≥ 2</em>┌m/2┐I-2；  </li><li>考虑第L层的结点个数为N+1，那么2*(┌m/2┐^(l-2)）≤N+1，也就是L层的最少结点数刚好达到N+1个，即： I≤ log┌m/2┐((N+1)/2 )+2；<br>所以   </li></ol><p><strong>当B树包含N个关键字时，B树的最大高度为l-1（因为计算B树高度时，叶结点所在层不计算在内），即：l - 1 = log┌m/2┐((N+1)/2 )+1.</strong><br>这个B树的高度公式从侧面显示了B树的查找效率是相当高的。<br><strong>一棵含有N个总关键字数的m阶的B树的最大高度是多少?<br>答：log_ceil（m/2）(N+1)/2 + 1 （上面中关于m阶B树的第1点特性已经提到：树中每个结点含有最多含有m个孩子，即m满足：ceil(m/2)&lt;=m&lt;=m。而树中每个结点含孩子数越少，树的高度则越大，故如此）。</strong></p><hr><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+tree：是应文件系统所需而产生的一种<strong>Btree的变形树</strong>。<br>一棵m阶的B+树和m阶的B树的异同点在于：<br>1.<strong>有n棵子树的结点中含有n-1 个关键字</strong>； (此处颇有争议，B+树到底是与B 树n棵子树有n-1个关键字 保持一致，还是不一致： <strong>B树n棵子树的结点中含有n个关键字</strong>，待后续查证。<br>2.<strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 <strong>(而B 树的叶子节点并没有包括全部需要查找的信息)</strong><br>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p><hr><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>B* -tree是<strong>B+-tree的变体</strong>，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B* 树中<strong>非根和非叶子结点再增加指向兄弟的指针</strong>；B* 树定义了非叶子结点关键字个数至少为(2/3)* M，即<strong>块的最低使用率为2/3（代替B+树的1/2）</strong>。  </p><p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。<br>B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。<br>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p><hr><p>内容参考/更多B-tree插入删除操作见<br><a href="https://blog.csdn.net/u013400245/article/details/52824744" target="_blank" rel="noopener">B树B+树的原理和操作</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用函数与注意事项</title>
      <link href="/2020/04/09/chang-yong-han-shu-yu-zhu-yi-shi-xiang/"/>
      <url>/2020/04/09/chang-yong-han-shu-yu-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><p><a href="https://blog.csdn.net/vir_lee/article/details/80560236" target="_blank" rel="noopener">C++学习之sort（），partial_sort()和partial_sort_copy()的使用与注意事项</a></p></li><li><p><a href="https://blog.csdn.net/AFishhhhhh/article/details/79980359" target="_blank" rel="noopener">C++ vector&amp; nums 用法一</a></p></li><li><p><a href="https://blog.csdn.net/cai_niaocainiao/article/details/81260902" target="_blank" rel="noopener">C++ replace() 函数用法</a></p></li><li><p><a href="https://blog.csdn.net/albertsh/article/details/96162344" target="_blank" rel="noopener">C++自定义全部替换函数replace</a></p></li><li><p><a href="https://blog.csdn.net/qq_33933704/article/details/79188028" target="_blank" rel="noopener">c++处理字符串string.find()与string::npos</a></p></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>用空指针尽可能的使用nullptr。<br><a href="https://blog.csdn.net/znzxc/article/details/80354434" target="_blank" rel="noopener">NULL与nullptr</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> acm </tag>
            
            <tag> icpc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
