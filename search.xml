<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020电影札记</title>
      <link href="/2020/04/09/dian-ying-zha-ji/"/>
      <url>/2020/04/09/dian-ying-zha-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我喜爱的电影导演"><a href="#我喜爱的电影导演" class="headerlink" title="我喜爱的电影导演"></a>我喜爱的电影导演</h2><ul><li>Stanley Kubrick</li><li>徐克</li><li>王家卫</li><li>Christopher Nolan</li><li>忻钰坤</li></ul><h2 id="我喜爱的电影"><a href="#我喜爱的电影" class="headerlink" title="我喜爱的电影"></a>我喜爱的电影</h2><ul><li>美丽人生</li><li>巴里·林登</li><li>东邪西毒 </li><li>末代皇帝</li><li>2001太空漫游 </li><li>万物理论</li><li>敦刻尔克</li><li>奇爱博士</li><li>思悼</li><li>杀人回忆</li><li>坠入 </li><li>全金属外壳</li><li>大话西游之月光宝盒</li><li>大话西游之大圣娶亲</li><li>梁祝</li></ul><h2 id="我喜爱的导演混剪-影片分析-采访"><a href="#我喜爱的导演混剪-影片分析-采访" class="headerlink" title="我喜爱的导演混剪/影片分析/采访"></a>我喜爱的导演混剪/影片分析/采访</h2><p><a href="https://www.bilibili.com/video/BV147411r7DA" target="_blank" rel="noopener">库布里克&amp;塔科夫斯基镜头对比</a></p><p><a href="https://www.xinpianchang.com/a52439?from=search_post" target="_blank" rel="noopener">娄烨导演电影混剪</a></p><p><a href="https://www.bilibili.com/video/BV1ps411P7h2" target="_blank" rel="noopener">徐克专访</a></p><p><a href="https://www.bilibili.com/video/BV1ub411a7ai" target="_blank" rel="noopener">盖里奇电影混剪</a></p><p><a href="https://www.bilibili.com/video/BV1uJ41157wV" target="_blank" rel="noopener">《敦刻尔克》结构性剪辑</a></p>]]></content>
      
      
      <categories>
          
          <category> 电影札记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影札记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 重复的数字</title>
      <link href="/2020/04/05/chong-fu-de-shu-zi/"/>
      <url>/2020/04/05/chong-fu-de-shu-zi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="03-重复的数字"><a href="#03-重复的数字" class="headerlink" title="03 重复的数字"></a>03 重复的数字</h2><blockquote><p>难度：简单</p></blockquote><blockquote><p>找出数组中重复的数字。</p></blockquote><blockquote><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p></blockquote><blockquote><p>示例 1：</p></blockquote><blockquote><p>输入：[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote><blockquote><p>限制：</p></blockquote><blockquote><p>2 &lt;= n &lt;= 100000</p></blockquote><p>思路：排序、比较、防止数组越界</p><p>代码：</p><pre><code>class Solution {         public:int findRepeatNumber(vector&lt;int&gt;&amp; nums) {       if(nums.size()&lt;=0) return -1;      sort(nums.begin(),nums.end()); //排序   for(int i = 1; i &lt; nums.size(); i++){       if((i+1)&lt;nums.size()){//防越界      if(nums[i-1]==nums[i]&amp;&amp;nums[i]!=nums[i+1]){//比较           return nums[i];      }          }     }    return nums[nums.size()-1];}};</code></pre><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" target="_blank" rel="noopener">来源：LeetCode</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 drag API</title>
      <link href="/2019/08/05/html5-drag-api/"/>
      <url>/2019/08/05/html5-drag-api/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML5-drag-API"><a href="#HTML5-drag-API" class="headerlink" title="HTML5 drag API"></a>HTML5 drag API</h2><h3 id="前言：mousedown事件"><a href="#前言：mousedown事件" class="headerlink" title="前言：mousedown事件"></a>前言：mousedown事件</h3><p>以前实现拖拽，主要有以下几步：</p><ol><li><p>目标元素绑定mousedown事件，记录下此时鼠标位置和拖拽元素的位置差，分别是 diffX ,diffY</p></li><li><p>在mousedown中绑定 document的mousemove 以及mouseup</p></li><li><p>在mousemove中计算拖拽元素的位置： x = event.clientX - diffX ,y = event.clientY - diffY</p></li><li><p>mouseup时中销毁绑定的 document mousemove 和mouseup事件，销毁拖拽元素</p></li></ol><p><strong>当一个元素拖拽的时候，鼠标顺序依次：mousedown,mousemove,mouseup,click</strong>, 如果一个元素既可以点击，又需要拖拽，可能导致，我们拖着拖着发生了点击事件，页面跳转了。这时候，我们通常会采用延时操作，避免误操作。总之，处理起来是麻烦的。</p><hr><h3 id="drag系列事件"><a href="#drag系列事件" class="headerlink" title="drag系列事件"></a>drag系列事件</h3><p>有了<strong>html5 drag</strong>，浏览器自动帮我们处理好了。需要注意的是,<strong>drag系列事件不能跟mousemove共存</strong>，只能取其一。</p><ul><li><p>拖拽和释放定义 </p><ul><li><p>拖拽：Drag;</p></li><li><p>释放：Drop;    </p></li></ul></li><li><p>源对象和目标对象</p><ul><li><p>Drop here(目标对象)</p></li><li><p>Drop me to my target(源对象)       </p></li></ul></li><li><p>相关API:</p><ul><li><p>ondragstart:事件主体是源对象，源对象开始被拖动时触发</p></li><li><p>ondrag:事件主体是源对象，源对象被拖动的过程时触发</p></li><li><p>ondragend:事件主体是源对象，在整个拖放操作结束时触发。</p></li><li><p>ondragenter:事件主体是目标对象，源对象进入目标元素时触发</p></li><li><p>ondragover:事件主体是目标对象，在源对象在目标对象内移动时触发。</p></li><li><p>ondragleave:事件主体是目标对象，源对象拖动着离开了目标对象时触发</p></li><li><p>ondrop:事件主体是目标对象，在目标元素完全接受被拖放元素时触发。</p></li></ul></li></ul><p>其中事件主体是拖放元素的是<strong>dragstart（开始拖动） 、darg（正在拖放） 、dragend（拖放结束）</strong>，其他4个事件主体都是目标元素，进入、移动、离开、完全进入四个状态。</p><hr><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>要让一个元素支持拖拽，首先我们需要在标签上标示出来：</p><pre><code>&lt;div draggable=&quot;true&quot;&gt;&lt;/div&gt;</code></pre><p>对于Safari，还必须要在CSS中对能拖拽的元素如下设置：</p><pre><code>*[draggable = true] {    -khtml-user-drag: element;}     </code></pre><p>注意：<strong>为了减少事件，你可以在事件 ondragenter 的时候绑定方法 ，而 ondragleave 的时候，删除方法。</strong> 最好不要绑定在 dragover 上，它就像 mouseover ，在拖动的过程中不断触发，对于浏览器的负担就很大了，浏览器还有可能崩溃。</p><pre><code>$(&#39;.test&#39;).on(&#39;dragstart&#39;,function(e){     console.log(&#39;start&#39;);});$(&#39;.test&#39;).on(&#39;dragend&#39;,function(){     console.log(&#39;end&#39;);})</code></pre><p>如此，就可以让元素拖动了。  </p><p>有了HTML5 drag API,判断拖拽元素跟其他dom元素相交变得容易起来了，只需要：</p><pre><code>$(&#39;.drop-area&#39;).on(&#39;dragover&#39;,function(e){    console.log(&#39;dragover&#39;);    e.preventDefault(); //需要注意的是，必须写上这个部分，如果不阻止默认事件，drop事件将不会触发。关于这点，可以去w3c查看。});$(&#39;.drop-area&#39;).on(&#39;drop&#39;,function(e){    console.log(&#39;drop&#39;);});</code></pre><hr><h3 id="dataTransfer对象实现数据交换"><a href="#dataTransfer对象实现数据交换" class="headerlink" title="dataTransfer对象实现数据交换"></a>dataTransfer对象实现数据交换</h3><ul><li><p>拖动的源对象和目标对象之间的数据传递：</p><ul><li><p>源对象数据保存：e.data.Transfer.setData(k,v)//k-v必须都是string类型</p></li><li><p>目标对象获取数据：e.data.Transfer.getData(k,v)</p></li></ul></li></ul><p>只有简单的拖放而没有数据变化是没有什么用的。为了在拖放操作时实现数据交换HTML5定义了<strong>dataTransfer对象</strong>来传递拖拽的数据。</p><p>因为它是事件对象的属性，所以只能在拖放事件的事件处理程序中访问dataTransfer对象。在事件处理程序中，可以使用这个对象的属性和方法来完善拖放功能。<br>getData()和setData()</p><p><strong>dataTransfer对象有 getData()和setData()两个主要方法</strong>，操作dataTransfer中携带的数据。不难想象，<strong>getData()可以取得由setData()保存的值。setData()方法的第一个参数，也是getDAta()方法唯一的一个参数，表示保存的数据类型</strong>。</p><p>IE只定义了“text”和“URL”两种有效的数据类型，而HTML5则对此加以扩展，允许指定各种MIME类型。考虑到向后兼容，HTML5也支持“text”和“URL”，但这两种类型会被映射为“text/plain”和“text/uri-list”。如下所示：</p><ul><li>text/html：文本文字格式</li><li>text/plain：HTML代码格式</li><li>text/xml：XML字符格式</li><li>text/url-list：URL格式列表</li></ul><p>实际上，dataTransfer对象可以为每种MIME类型都保存一个值。换句话说，同时在这个对象中保存了一段文本和一个URL不会有任何问题。不过，保存在dataTransfer对象中的数据只能在drop事件处理程序中读取。如果在ondrop处理程序中没有读到数据，那就是dataTransfer对象已经被销毁，数据也丢失了。</p><p>在拖动文本框中的文本时，浏览器会调用setData()方法，将拖动的文本以“text”格式保存在dataTransfer对象中。类似地，在拖放链接或图像时，会调用setData()方法并保存URL。然后，在这些元素被拖放到放置目标时，就可以通过getData()读到这些数据。当然，作为开发人员，你也可以在dragstart事件处理程序中调用setData()，手工保存自己要传输的数据，以便将来使用。</p><p>将数据保存为文本和保存为URL是有区别的。如果将数据保存为文本格式，那么数据不会得到任何特殊处理。而如果将数据保存为URL，浏览器会将其当成网页中的链接。换句话说，如果你把它放置到另一个浏览器窗口中，浏览器就会打开该URL。</p><p>Firefox在其第5个版本之前不能正确地将“URL”和“text”映射为“text/uri-list”和“text/plain”。但是却能把“Text”映射为“text/plain”。为了更好地在跨浏览器的情况下从dataTransfer对象取得数据，最好在取得URL数据时检测两个值，而在取得文本数据时使用“text”。</p><p>var dataTransfer =event.dataTransfer;//读取URLvar url = dataTransfer.getData(“url”)|| dataTransfer.getData(“text/uri-list”);//读取文本var text = dataTransfer.getData(“Text”);</p><p>注意：一定要把短数据类型放在前面，因为IE 10及之前的版本仍然不支持扩展的MIME类型名，而它们在遇到无法识别的数据类型时，会抛出错误。</p><hr><h3 id="使用-setDragImage-方法设置拖放图标"><a href="#使用-setDragImage-方法设置拖放图标" class="headerlink" title="使用 setDragImage 方法设置拖放图标"></a>使用 setDragImage 方法设置拖放图标</h3><p>在HTML5中，一个元素在被拖放时，还可以自定义拖放元素的鼠标图标。调用格式如下：</p><pre><code>setDragImage(Element img,long x,long y); //img表示拖放时的 &lt;&gt; 元素的图标，x 表示图标距离鼠标指针的x轴方向的偏移值，y表示图标距离鼠标指针y轴方向的偏移值。</code></pre><hr><h3 id="使用-effectAllowed-和-dropEffect-属性设置拖放效果"><a href="#使用-effectAllowed-和-dropEffect-属性设置拖放效果" class="headerlink" title="使用 effectAllowed 和 dropEffect 属性设置拖放效果"></a>使用 effectAllowed 和 dropEffect 属性设置拖放效果</h3><p>dataTransfer对象的两个属性：dropEffect和effectAllowed，能通过它来确定被拖动的元素以及作为放置目标的元素能够接受什么操作。结合effectAllowed 和 dropEffect 这两个属性，可以自定义拖放过程中的效果。两个属性虽然都是为了实现同一功能，但绑定的元素不同：<strong>effectAllowed属性作用于被拖放元素；而 dropEffect 属性作用于目标元素。</strong></p><p>其中，通过dropEffect属性可以知道被拖动的元素能够执行哪种放置行为。这个属性有下列4个可能的值。  </p><ul><li>none：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。</li><li>move：应该把拖动的元素移动到放置目标</li><li>copy：应该把拖动的元素复制到放置目标</li><li>link：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有URL）。</li></ul><p>在把元素拖动到放置目标上时，以上每一个值都会导致光标显示为不同的符号。然而，要怎样实现光标所指示的动作完全取决于你。换句话说，如果你不介入，没有什么会自动地移动、复制，也不会打开链接。总之，浏览器只能帮你改变光标的样式，而其它的都要靠你自己来实现。要使用dropEfect属性，必须在ondraggenter事件处理程序中针对放置目标来设置它。</p><p>dropEffect属性只有搭配effectAllowed属性才有用。effectAllowed属性表示允许拖放元素的哪种dropEffect，effectAllowed属性可能的值如下。</p><ul><li>uninitialized：没有该被拖动元素放置行为。</li><li>none：被拖动的元素不能有任何行为。</li><li>copy：只允许值为“copy”的dropEffect。</li><li>link：只允许值为“link”的dropEffect。</li><li>move：只允许值为“move”的dropEffect。</li><li>copyLink：允许值为“copy”和“link”的dropEffect。</li><li>copyMove：允许值为“copy”和”link”的dropEffect。</li><li>linkMove：允许职位“link”和”move”的dropEffect。</li><li>all：允许任意dropEffect。</li></ul><p>必须在ondraggstart事件处理程序中设置effectAllowed属性。</p><p>假设你想允许用户把文本框中的文本拖放到一个<div>元素中。首先，必须将dropEffect和effectAllowed设置为”move”。但是，由于<div>元素的放置事件的默认行为是什么也不做，所以文本不可能自动移动。重写这个默认行为，就能从文本框中移走文本。然后你就可以自己编写代码将文本插入到<div>中，这样整个拖放操作就完成了。如果将dropEffect和effectAllowed的值设置为”copy”，那就不会自动移走文本框中的文本。<br>其它属性</div></div></div></p><ul><li>addElement：事件主体是被拖放元素，为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖动源而影响回调的对象），不会影响拖动操作时页面元素的外观。在写作文本时，只有Firefox 3.5+实现了这个方法。</li><li>clearData：事件主体是目标元素，清除以特定格式保存的数据。实现这个方法的浏览器有IE、Firefox 3.5、Chrome和Safari 4+。</li><li>types：当前保存的数据类型。这是一个类似数组的集合，以“text”这样的字符串形式保存着数据类型。实现这个属性的浏览器有IE10+、Firefox 3.5+和Chrome。</li></ul><p>支持draggable属性的浏览器有IE10+、Firefox 4+、Safari 5+和Chrome。Opera 11.5以及之前的版本都不支持HTML5的拖放功能。另外，为了让Firefox 支持可拖动属性，还必须添加一个ondragstart事件处理程序，并在dataTransfer对象中保存了一些信息。  </p><hr><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p><a href="https://www.cnblogs.com/wuya16/p/DragApi.html" target="_blank" rel="noopener">html5 drag api详解</a>  </p><p><a href="https://www.cnblogs.com/yangguoe/p/9681692.html" target="_blank" rel="noopener">html5的拖拽dragAPI（包含三个案例)</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记——搜索算法</title>
      <link href="/2019/07/09/sou-suo-suan-fa/"/>
      <url>/2019/07/09/sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="基本搜索算法"><a href="#基本搜索算法" class="headerlink" title="基本搜索算法"></a>基本搜索算法</h3><blockquote><ol><li>枚举算法  <ul><li>列举问题的所有状态从而寻找符合问题的解的方法。  </li><li>适合用于<strong>状态较少，比较简单</strong>的问题上。  </li></ul></li><li>广度优先搜索（BFS）  六度  <ul><li>从初始点开始，根据规则展开第一层节点，并检查目标节点是否在这些节点上，若没有，再将所有的第一层的节点逐一展开，得到第二层节点，如没有，则扩展下去，直到发现目标节点为止。   </li><li>比较适合求<strong>最少步骤或最短解序列</strong>的题目。   </li><li><strong>一般设置一个队列queue</strong>，将起始节点放入队列中，然后从队列头取出一个节点，检查是否是目标节点，如不是则进行扩展，将扩展出的所有节点放到队尾，然后再从队列头取出一个节点，直至找到目标节点。  </li></ul></li><li>深度优先搜索（DFS）  <ul><li><strong>一般设置一个栈stack</strong>，将起始节点放入栈中，然后从栈中弹出一个节点，检查是否是目标节点，如不是则进行扩展，将扩展出的所有节点入栈，然后再从栈顶弹出一个节点，直到找到目标节点。   </li><li><strong>深度优先搜索得到的第一个解，不一定是最优解</strong>。  </li></ul></li><li>A*算法  <ul><li>利用问题的规则和特点来制定一些启发规则，由此来改变节点的扩展顺序，将最有希望扩展出最优解的节点优先扩展，使得尽快找到最优解。  </li><li>对每一个节点，有一个估价函数F来估算起始节点经过该节点到达目标节点的最佳路径的代价。  </li><li><strong>每个节点扩展的时候，总是选择具有最小的F的节点</strong>。  </li><li><strong>F=G+B×H</strong>：G为从起始节点到当前节点的实际代价，已经算出，H为从该节点到目标节点的最优路径的估计代价。F要单调递增。  </li><li>B最好随着搜索深度成反比变化，在搜索深度浅的地方，主要让搜索依靠启发信息，尽快的逼近目标，而当搜索深的时候，逐渐变成广度优先搜索。  </li></ul></li><li>回溯算法  <ul><li>回溯算法是一种系统的搜索问题的解题方法。它的基本思想是：从一条路前行，能进则进，不能进则退回来，换一条路再试。回溯法是一种通用的解题方法  </li><li>和深度优先相似，不同之处在于<strong>对一个节点扩展的时候，并不将所有的子节点扩展出来</strong>，而只扩展其中的一个。因而<strong>具有盲目性，但内存占用少</strong>。 </li></ul></li></ol></blockquote><hr><h3 id="搜索算法优化"><a href="#搜索算法优化" class="headerlink" title="搜索算法优化"></a>搜索算法优化</h3><blockquote><ul><li>在搜索前，根据条件降低搜索规模。   <ul><li>广度优先搜索中，<strong>被处理过的节点，充分释放空间</strong>。    </li><li>根据问题的约束条件进行<strong>剪枝</strong>。   </li><li>利用搜索过程中的中间解，避免重复计算。      </li></ul></li></ul></blockquote><blockquote><ol><li><strong>剪枝</strong>函数<br>对于回溯算法，需要搜索整棵解空间树，剪枝顾名思义，就是通过某种判断，避免一些不必要的遍历过程，剪去解空间树中的一些不必要的枝条，从而缩小整个搜索的规模。  <ol start="2"><li><strong>双向广度搜索</strong><br>所谓双向广度搜索，故名思议指的是搜索沿正向（从初始结点向目标结点方向搜索）和逆向（从目标结点向初始结点方向搜索）两个方向同时进行，当两个方向上的搜索生成同一子结点时完成搜索过程。  <ul><li>从起始节点向目标节点方向搜索，同时从目标节点向起始节点方向搜索。  </li><li>双向搜索<strong>只能用于广度优先搜索</strong>中。    </li><li>双向搜索扩展的<strong>节点数量要比单向少的多</strong>。  </li><li>运用双向广度搜索理想上可以<strong>减少二分之一的搜索量，从而提高搜索效率</strong>。  </li><li>双向广度搜索一般有两种方法：<ul><li>一种是两个方向交替扩展，</li><li>另一种是选择结点个数比较少的方向先扩展。<ul><li>显然第一种方法比第二种方法容易实现，但是由于<strong>第二种方法克服了双向搜索中结点生成速度不平衡的状态，效率将比第一种方法高</strong>。  </li></ul></li></ul></li></ul></li></ol></li></ol></blockquote><hr><h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><ul><li>数的划分<ul><li>对n=m+（n-m），分解时用深搜</li><li>对数m与n-m用回溯递归法搜索。</li></ul></li><li>闪避湖泊<ul><li>深搜</li></ul></li><li>信道分配  <ul><li>构造无向图</li><li>深搜</li></ul></li><li>骑士移动<ul><li>深搜广搜都可，但深搜速度慢量大，广搜效率更高。 </li></ul></li><li>图像周长<ul><li>深搜</li></ul></li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li><a href="http://poj.org/problem?id=1915" target="_blank" rel="noopener">移动的骑士</a></li><li><a href="http://poj.org/problem?id=1426" target="_blank" rel="noopener">寻找M</a></li><li><a href="http://poj.org/problem?id=1979" target="_blank" rel="noopener">红与黑</a></li><li><a href="http://poj.org/problem?id=1011" target="_blank" rel="noopener">小木棒</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常用</title>
      <link href="/2019/07/05/qian-duan-chang-yong/"/>
      <url>/2019/07/05/qian-duan-chang-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><p><a href="http://www.h-ui.net/site.shtml" target="_blank" rel="noopener">前端网址导航 - H-ui前端框架官方网站</a></p></li><li><p><a href="https://www.bootcss.com/" target="_blank" rel="noopener">Bootstrap中文网</a></p></li><li><p><a href="https://www.w3school.com.cn/index.html" target="_blank" rel="noopener">w3school</a></p></li><li><p><a href="https://www.youzhan.org/page/2/" target="_blank" rel="noopener">Bootstrap 网页精选</a></p></li><li><p><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴矢量图标库</a></p></li></ul><hr><h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><a href="http://bg-patterns.com/?paged=36" target="_blank" rel="noopener">Bg-patterns 背景パターン配布＆作成サイト </a> </li></ul><h3 id="插画"><a href="#插画" class="headerlink" title="插画"></a>插画</h3><ul><li><a href="https://iradesign.io/gallery/illustrations" target="_blank" rel="noopener">IRA Design</a> </li><li><a href="https://undraw.co/illustrations" target="_blank" rel="noopener">Undraw</a></li><li><a href="https://www.glazestock.com/" target="_blank" rel="noopener">Glaze</a></li><li><a href="https://airtable.com/" target="_blank" rel="noopener">Airtable</a> (插画插件)</li></ul><hr><h2 id="logo制作"><a href="#logo制作" class="headerlink" title="logo制作"></a>logo制作</h2><ul><li><a href="https://www.canva.com/" target="_blank" rel="noopener">canva</a> （常用、中文、免费）</li><li><a href="https://www.graphicsprings.com/zh" target="_blank" rel="noopener">graphicsprings</a>（免费、每日更新）</li><li><a href="https://www.ucraft.com/free-logo-maker" target="_blank" rel="noopener">ucraft</a> （免费、高分辨率）</li><li><a href="https://hatchful.shopify.com/" target="_blank" rel="noopener">hatchful</a></li><li><a href="https://www.designhill.com/tools/logo-maker" target="_blank" rel="noopener">designhill</a>（免费）</li><li><a href="https://www.tailorbrands.com/" target="_blank" rel="noopener">tailorbrands</a> （快速设计）</li><li><a href="https://www.logogarden.com/" target="_blank" rel="noopener">logogarden</a>（快速设计）</li><li><a href="https://www.logogenie.net/" target="_blank" rel="noopener">logogenie</a> （免费、快速设计）</li></ul><hr><h2 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h2><ul><li><a href="https://www.iconfont.cn/collections/detail?cid=16265" target="_blank" rel="noopener">黄色小图标1</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16257" target="_blank" rel="noopener">黄色小图标2</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16317" target="_blank" rel="noopener">黄色小图标3</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16393" target="_blank" rel="noopener">蓝色小图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16539" target="_blank" rel="noopener">蓝色小图标·CRM_icon</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16649" target="_blank" rel="noopener">蓝色小图标·企业组织专用图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=16150" target="_blank" rel="noopener">紫色小图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16505" target="_blank" rel="noopener">紫色小图标·娱乐类线性图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16717" target="_blank" rel="noopener">灰色小图标1</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16740" target="_blank" rel="noopener">灰色小图标2</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16749" target="_blank" rel="noopener">灰色小图标·音乐</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16754" target="_blank" rel="noopener">灰色小图标·吃货大收集</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16814" target="_blank" rel="noopener">灰色小图标·天气</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16880" target="_blank" rel="noopener">灰色小图标·供应链平台</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=15672" target="_blank" rel="noopener">彩色通讯线性图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=16240" target="_blank" rel="noopener">彩色工作图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=16147" target="_blank" rel="noopener">彩色智能科技图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?cid=16458" target="_blank" rel="noopener">彩色商业金融类扁平图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16468" target="_blank" rel="noopener">彩色金融营销图标</a></li><li><a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.1998910419.d9df05512&cid=16470" target="_blank" rel="noopener">彩色卡通警示类图标</a></li></ul><hr><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p><a href="http://www.divcss5.com/rumen/r403.shtml" target="_blank" rel="noopener">CSS position绝对定位absolute relative</a></p></li><li><p><a href="https://www.html5tricks.com/css3-hyperlink-animation.html" target="_blank" rel="noopener">CSS3自定义样式超链接按钮 鼠标滑过带动画特效</a>  </p></li><li><p><a href="https://www.html5tricks.com/css3-3d-svg-button.html" target="_blank" rel="noopener">3D质感CSS3按钮 按钮内容支持SVG</a></p></li><li><p><a href="https://www.html5tricks.com/pure-css3-switch-radio.html" target="_blank" rel="noopener">纯CSS3开关样式的自定义单选框</a>  </p></li></ul><hr><h2 id="设计风格"><a href="#设计风格" class="headerlink" title="设计风格"></a>设计风格</h2><ul><li><p><a href="https://www.atlassian.com/time-wasting-at-work-infographic" target="_blank" rel="noopener">You Waste A Lot Of Time At Work</a></p></li><li><p><a href="http://www.qinxue.com/284.html?sysref=2d5" target="_blank" rel="noopener">2.5D插画入门与进阶教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常用</title>
      <link href="/2019/07/05/chang-yong-han-shu-yu-zhu-yi-shi-xiang/"/>
      <url>/2019/07/05/chang-yong-han-shu-yu-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><pre><code>#include &quot;bits/stdc++.h&quot;using namespace std;#include &lt;string&gt;   //C++#include &lt;string.h&gt; //C#include &lt;stdlib.h&gt; //含有将字符串整数相互转换的函数#include &lt;algorithm&gt; //sort()</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>多组输入输出  </p><pre><code> while(~scanf(&quot;%d&quot;,&amp;n)){}</code></pre></li><li><p>数组所有数置零  </p><pre><code> memset(cnt,0,sizeof(cnt));  </code></pre></li><li><p>去多余字符  </p><pre><code> getchar();  </code></pre></li><li><p>字符处理函数  </p><pre><code> 在ctype.h头文件中 int isdigit(int c) //判断c是否是数字字符，是则返回1，否则返回0，下同。 int isalpha(int c) //判断c是否是一个字母 int isalnum(int c) //判断c是否是一个数字或字母 int islower(int c) //判断c是否是一个小写字母 int isupper(int c) //判断c是否是一个大写字母 int toupper(int c) //如果c是一个小写字母，则返回其大写字母 int tolower(int c) //如果c是一个大写字母，则返回其小写字母</code></pre></li><li><p>字符串和内存操作函数  </p><pre><code> char * strcpy(char * s1, char * s2) //将字符串s1内容拷贝到s2 char * strncpy(char * s1, char * s2,int n) //将字符串s1拷贝到s1,但最多拷贝n个字节。若拷贝字节数达到n，就不会往s1中写入结尾的&#39;\0&#39; char * strcat(char * s1, char * s2) //将s2添加到s1末尾 int strcmp(char * s1, char * s2) //比较两字符串，大小写相关。返回值&lt;0，则s1按字典顺序在s2前。返回值=0，字符串一样。返回值&gt;0，s1在s2后。 int stricmp(char * s1, char * s2) //比较两字符串，大小写无关。返回值&lt;0，则s1按字典顺序在s2前。返回值=0，字符串一样。返回值&gt;0，s1在s2后。   int strlen(const char *string) //计算字符串长度 char *strncat(char *strDestination, const char *strSource, size_t count) //将字符串前count个字符添加到字符串strDestination末尾 int strncmp(const char *string1, const char *string2, size_t count) //分别取两个字符串的前count个字符作为子字符串，比较大小。 char *strrev(char *string) //将字符串string前后颠倒 void *memcpy(void * s1,void *s2 ,int n) //将s2处的n字节拷贝到s1 void *memset(void *s,int c,int n) //将s开始的n个字节全部置c  </code></pre></li><li><p>字符串与数相互转换的函数（定义在stdlib.h中）  </p><pre><code> int atoi(char *s) //字符串s内容转为整型数返回，s=&quot;1234&quot;,返回1234 double atof(char *s) //字符串s转为浮点数 char *itoa(int value,char *string ,int radix) //整数value以radix进制表写入string</code></pre></li></ul><ul><li><p><a href="https://blog.csdn.net/vir_lee/article/details/80560236" target="_blank" rel="noopener">C++学习之sort（），partial_sort()和partial_sort_copy()的使用与注意事项</a></p></li><li><p><a href="https://blog.csdn.net/AFishhhhhh/article/details/79980359" target="_blank" rel="noopener">C++ vector&amp; nums 用法一</a></p></li><li><p><a href="https://blog.csdn.net/cai_niaocainiao/article/details/81260902" target="_blank" rel="noopener">C++ replace() 函数用法</a></p></li><li><p><a href="https://blog.csdn.net/albertsh/article/details/96162344" target="_blank" rel="noopener">C++自定义全部替换函数replace</a></p></li><li><p><a href="https://blog.csdn.net/qq_33933704/article/details/79188028" target="_blank" rel="noopener">c++处理字符串string.find()与string::npos</a></p></li></ul><h3 id="常用缩写"><a href="#常用缩写" class="headerlink" title="常用缩写"></a>常用缩写</h3><table><thead><tr><th>原词</th><th align="center">缩写</th><th align="center">原词</th><th align="center">缩写</th><th align="center">原词</th><th align="right">缩写</th></tr></thead><tbody><tr><td>absolute</td><td align="center">abs</td><td align="center">error</td><td align="center">err</td><td align="center">operator</td><td align="right">optr</td></tr><tr><td>addition</td><td align="center">add</td><td align="center">float</td><td align="center">flt</td><td align="center">packet</td><td align="right">pkt</td></tr><tr><td>adjust</td><td align="center">adj</td><td align="center">form</td><td align="center">frm</td><td align="center">position</td><td align="right">pos</td></tr><tr><td>answer</td><td align="center">ans</td><td align="center">four</td><td align="center">4</td><td align="center">previous</td><td align="right">pre或prev</td></tr><tr><td>array</td><td align="center">arr</td><td align="center">frequency</td><td align="center">freq</td><td align="center">payload type</td><td align="right">pt</td></tr><tr><td>average</td><td align="center">avg</td><td align="center">function</td><td align="center">fun</td><td align="center">pointer</td><td align="right">ptr</td></tr><tr><td>buffer</td><td align="center">buf或buff</td><td align="center">header</td><td align="center">hdr</td><td align="center">return code</td><td align="right">rc</td></tr><tr><td>capture</td><td align="center">cap或capt</td><td align="center">index</td><td align="center">idx</td><td align="center">record</td><td align="right">rcd</td></tr><tr><td>check</td><td align="center">chk</td><td align="center">image</td><td align="center">img</td><td align="center">receive</td><td align="right">recv</td></tr><tr><td>count</td><td align="center">cnt</td><td align="center">increment</td><td align="center">inc</td><td align="center">result</td><td align="right">res</td></tr><tr><td>column</td><td align="center">col</td><td align="center">initialize</td><td align="center">init</td><td align="center">return</td><td align="right">ret</td></tr><tr><td>compare</td><td align="center">cmp</td><td align="center">iteration</td><td align="center">itr</td><td align="center">source</td><td align="right">src</td></tr><tr><td>control</td><td align="center">ctrl</td><td align="center">length</td><td align="center">len</td><td align="center">stack</td><td align="right">stk</td></tr><tr><td>decode</td><td align="center">dec</td><td align="center">memory</td><td align="center">mem</td><td align="center">string</td><td align="right">str</td></tr><tr><td>define</td><td align="center">def</td><td align="center">middle</td><td align="center">mid</td><td align="center">subtraction</td><td align="right">sub</td></tr><tr><td>delete</td><td align="center">del</td><td align="center">make</td><td align="center">mk</td><td align="center">table</td><td align="right">tab</td></tr><tr><td>destination</td><td align="center">dst或dest</td><td align="center">message</td><td align="center">msg</td><td align="center">temporary</td><td align="right">tmp或temp</td></tr><tr><td>display</td><td align="center">disp</td><td align="center">multiplication</td><td align="center">mul</td><td align="center">to</td><td align="right">2</td></tr><tr><td>division</td><td align="center">div</td><td align="center">number</td><td align="center">num</td><td align="center">total</td><td align="right">tot</td></tr><tr><td>encode</td><td align="center">enc</td><td align="center">operand</td><td align="center">opnd</td><td align="center">time stamp</td><td align="right">ts</td></tr><tr><td>environment</td><td align="center">env</td><td align="center">optimization</td><td align="center">opt</td><td align="center">value</td><td align="right">val</td></tr></tbody></table><hr><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>用空指针尽可能的使用nullptr。<br><a href="https://blog.csdn.net/znzxc/article/details/80354434" target="_blank" rel="noopener">NULL与nullptr</a></p></li><li><p>太大的数定义在main外</p><pre><code> #define N 10010 int cnt[N];</code></pre></li><li><p>高精度计算  </p><ul><li>有符号整数（int）能表示的范围是-263－263– 1，即-9223372036854775808~ 9223372036854775807。</li><li>无符号整数（unsigned int）类型能表示的范围是0－264– 1，即0~18446744073709551615。</li><li>因此int和unsigned类型变量，都不能保存超过<strong>19位</strong>的整数。  </li><li>数组存储：数组unsigned an[201]来保存一个200位的整数，让an[0]存放个位，an[1]存十位，……</li></ul></li><li><p>其它</p><ul><li><p>%-7d  右对齐显示7位</p></li><li><p>t1=t1&lt;&lt;1;  //“&lt;&lt;”左移即乘2，时间复杂度比用“ * ”更快  </p></li><li><p>a[i]=1-a[i] //0&lt;=&gt;1</p></li><li><p>把一个数加0.5再int,可实现四舍五入</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发赛记录</title>
      <link href="/2019/04/05/wei-xin-xiao-cheng-xu-kai-fa-sai-ji-lu/"/>
      <url>/2019/04/05/wei-xin-xiao-cheng-xu-kai-fa-sai-ji-lu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h2><ul><li><p><a href="https://www.imooc.com/learn/795" target="_blank" rel="noopener">axure软件学习课程</a>  </p></li><li><p>原型旁写上操作说明和数据来源、输出结果等信息。</p></li><li><p>微信小程序没有限制5层（<a href="https://segmentfault.com/a/1190000012282464" target="_blank" rel="noopener">微信小程序页面5层限制的一种解决方案</a>），但设计产品的时候，尽量不要进入超过5层，超过了5层，这个产品容易出现问题。</p></li><li><p>Mark Man标注颜色、尺寸</p></li></ul><hr><h2 id="小程序端"><a href="#小程序端" class="headerlink" title="小程序端"></a>小程序端</h2><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><ul><li>使用Color-UI组件库</li></ul><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul><li>引导页</li><li>导航栏:利用navigator组件导航跳转，自定义底部导航栏tarbar样式，并隐藏系统tarBar组件。（自定义封装组件component的好处：各个tarbar页只需调用editTarbar、调用组件即可）</li><li>搜索记录盒子、记录词盒子中词的增加删除：利用数据绑定以及获取缓存，获取历史搜索值，并清空历史搜索值。</li><li>实现指定内容的收藏与取消收藏：longTap事件监听用户是否进行长按，再利用缓存及数据绑定，实现收藏与取消收藏。</li><li>实现滑动选择背景图：使用scroll-view可滚动视图组件。</li><li>用canvas自定义绘图，绘制指定内容(句子信息以及小程序推广二维码)，调用小程序官方API wx.saveImageToPhotosAlbum将图片保存到本地。</li><li>由于canvas绘制过长文字时不会自动换行，因此需要处理文本换行问题，调用drawText。</li><li>调用官方APIcanvasToTempFilePath，将绘制好的图片保存为图片(png类型)（对像素比处理，防止图片模糊）</li><li>利用swiper组件实现滑动切换选项卡操作，利用当前页面currentData，显示对应页面，对应页面为swiper-item内的内容。</li><li>利用模板template生成模板，简易修改。</li><li>通过数据绑定，实现选择菜单后的数据显示，逻辑判断当前菜单选择的数据，更新前端数据current_name。</li><li>小程序右上角转发消息函数onShareAppMessage，自定义转发消息</li><li><a href="https://www.jianshu.com/p/7ad22e35b556" target="_blank" rel="noopener">微信小程序：长按点击事件实现</a></li><li><a href="https://www.jianshu.com/p/96150ed09e3a" target="_blank" rel="noopener">微信小程序实现同时单击、双击、长按</a></li><li><a href="http://www.yiyongtong.com/archives/view-286-1.html" target="_blank" rel="noopener">小程序长按事件触发点击事件的BUG处理</a></li><li><a href="https://www.cnblogs.com/laiqiangjin/p/8963133.html" target="_blank" rel="noopener">小程序的长按事件和点击事件</a></li></ul><hr><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li>bmob后端云做数据存储管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树、B+树、B*树</title>
      <link href="/2018/04/09/b-shu-b-shu-b-cheng-shu/"/>
      <url>/2018/04/09/b-shu-b-shu-b-cheng-shu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="B树、B-树、B-树"><a href="#B树、B-树、B-树" class="headerlink" title="B树、B+树、B*树"></a>B树、B+树、B*树</h1><hr><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><ul><li>B树：二叉树 ，有序数组+平衡多叉树；  </li><li>B-树：是一种多路搜索树   </li><li>B+树：B+树是B-树的变体，也是一种多路搜索树。非叶子结点的子树指针与关键字个数相同，有序数组链表+平衡多叉树；  </li><li>B*树：一棵丰满的B+树。是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</li></ul><hr><ol><li><ul><li>B+树<strong>方便扫库</strong>  </li><li>B树必须用<strong>中序遍历</strong>的方法按序扫库<br>B+树直接从叶子结点挨个扫一遍就完了  </li></ul></li><li><ul><li>B+树支持 <strong>range-query（范围查询）</strong>非常方便，而B树不支持。这是数据库选用B+树的最主要原因。<br>比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。  </li><li>B树的好处，就是<strong>成功查询</strong>特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。<br>B树比如你的例子中查，17，一把就得到结果了，<br>有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。</li></ul></li></ol><hr><ul><li>B树比连续内存空间的二分查找的优点是，改变B树结构(插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销</li><li>B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引B+-tree的查询效率更加稳定</li><li>B*树分配新结点的概率比B+树要低，空间使用率更高</li></ul><hr><p>B树<br><img src="/2018/04/09/b-shu-b-shu-b-cheng-shu/1.jpg" alt="B树">      </p><p>B+树<br><img src="/2018/04/09/b-shu-b-shu-b-cheng-shu/2.jpg" alt="B+树">   </p><p>B*树     </p><p><img src="/2018/04/09/b-shu-b-shu-b-cheng-shu/3.jpg" alt="B*树"></p><hr><h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><blockquote><p>B 树又叫平衡多路查找树。一棵m阶的B 树 (注：切勿简单的认为一棵m阶的B树是m叉树，虽然存在四叉树，八叉树，KD树，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同)的特性如下：</p></blockquote><blockquote><ol><li><strong>树中每个结点最多含有m个孩子（m&gt;=2）</strong>；  </li><li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；  </li><li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；  </li><li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；（读者反馈@冷岳：这里有错，叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。@研究者July：其实，关键是把什么当做叶子结点，因为如红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。  </li><li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。<br>b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。<br>c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</li></ol></blockquote><blockquote><p><strong>B树的高度</strong><br><strong>(┌M/2┐是向上取整,即取与结果最接近的比结果大的整数,┌3/2┐=2； └M/2┘是向下取整,即取与结果最接近的比结果小的整数,└3/2┘=1.)</strong>  </p></blockquote><blockquote><ol><li>因为根至少有两个孩子，因此第2层至少有两个结点。  </li><li>除根和叶子外，其它结点至少有┌m/2┐个孩子，  </li><li>因此在第3层至少有2*┌m/2┐个结点，  </li><li>在第4层至少有2*(┌m/2┐^2)个结点，  </li><li>在第 I 层至少有2<em>(┌m/2┐^(l-2) )个结点，于是有： N+1 ≥ 2</em>┌m/2┐I-2；  </li><li>考虑第L层的结点个数为N+1，那么2*(┌m/2┐^(l-2)）≤N+1，也就是L层的最少结点数刚好达到N+1个，即： I≤ log┌m/2┐((N+1)/2 )+2；<br>所以   </li></ol><p><strong>当B树包含N个关键字时，B树的最大高度为l-1（因为计算B树高度时，叶结点所在层不计算在内），即：l - 1 = log┌m/2┐((N+1)/2 )+1.</strong><br>这个B树的高度公式从侧面显示了B树的查找效率是相当高的。<br><strong>一棵含有N个总关键字数的m阶的B树的最大高度是多少?<br>答：log_ceil（m/2）(N+1)/2 + 1 （上面中关于m阶B树的第1点特性已经提到：树中每个结点含有最多含有m个孩子，即m满足：ceil(m/2)&lt;=m&lt;=m。而树中每个结点含孩子数越少，树的高度则越大，故如此）。</strong></p></blockquote><hr><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><blockquote><p>B+tree：是应文件系统所需而产生的一种<strong>Btree的变形树</strong>。<br>一棵m阶的B+树和m阶的B树的异同点在于：<br>1.<strong>有n棵子树的结点中含有n-1 个关键字</strong>； (此处颇有争议，B+树到底是与B 树n棵子树有n-1个关键字 保持一致，还是不一致： <strong>B树n棵子树的结点中含有n个关键字</strong>，待后续查证。<br>2.<strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 <strong>(而B 树的叶子节点并没有包括全部需要查找的信息)</strong><br>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p></blockquote><hr><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><blockquote><p>B* -tree是<strong>B+-tree的变体</strong>，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B* 树中<strong>非根和非叶子结点再增加指向兄弟的指针</strong>；B* 树定义了非叶子结点关键字个数至少为(2/3)* M，即<strong>块的最低使用率为2/3（代替B+树的1/2）</strong>。  </p></blockquote><blockquote><p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。<br>B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。<br>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p></blockquote><hr><p>内容参考/更多B-tree插入删除操作见<br><a href="https://blog.csdn.net/u013400245/article/details/52824744" target="_blank" rel="noopener">B树B+树的原理和操作</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
